[
["index.html", "R 資料科學與統計 序言", " R 資料科學與統計 Jeff Lin 2020-09-12 序言 R 可視為統計數學軟體, 也是一種程式語言, 而近年來的發展, R 更成為資料科學的熱門的工具之一. R 是一個免費的統計分析軟體 (open-source, GNU General Public License), R 由一群跨國際的志工人員組成的 {R} 核心發展組織 (R core-development team) 所維持, 運作與持續更新發展. 目前對初學者的 R 入門學習有二大主要論點, 一為學習使用 R Base 原始語言與原始套件, 二為直接學習外部套件, 如 ggplot2, tidyverse 系統. 無論哪一種方式亙有其優缺點. 個人認為對未來必須經常性使用 R 進行資料分析工作的初學者, 則建議先學習使用 R Base 原始語言. 對於未來僅在少數時間必須使用 R 進行資料分析工作, 或是僅在統計學上課使用, 則建議學習 ggplot2, tidyverse 等外部套件. 至於已經具有其他程式語言基礎, 則二者學習方式無多大差別. 作者個人對學習使用 R Base 原始語言與原始套件的介紹, 可參考 R 程式語言與醫學統計. 目前有許多 R 書籍, 寫作本書主要是為了個人上課方便使用, 本書的主要寫作對象為醫師或醫學研究人員, 以及使用 R 輔助學習統計的大學生為主, 假設讀者沒有太多統計資料分析概念或經驗, 也無程式語言寫作經驗. 主要介紹使用 ggplot2, tidyverse 系統套件進資料分析工作, 主要參考來源 https://r4ds.had.co.nz/ 與 https://rstudio-education.github.io/hopr/. 但學習歷程很難將二者完全切割, 通常會交錯並進. 本書前面章節資料使用醫學相關資料或是基礎統計學相關資料, 先降低資料的複雜性有助於了解 R 統計程式語言的核心, 後面章節再導入大數據分析. 本書關於 R base 多數摘取本人 R base 內容, R 程式語言與醫學統計, 本書使用 R bookdown package 寫作 (Xie 2020), 方便隨時更新內容. References "],
["intro.html", "Chapter 1 R 語言基本概論 1.1 下載與安裝 R 1.2 下載與安裝 RSudio 1.3 簡單實例 1.4 物件 Object 1.5 使用指令 1.6 查詢顯示物件與刪除物件 1.7 程式中止操作 1.8 工作目錄 1.9 程式編輯軟體與整合系統 RStudio 1.10 函式 Function 1.11 套件 Packages 1.12 解說與輔助文件 1.13 地區語系與時區", " Chapter 1 R 語言基本概論 R 系統是由 Ross Ihaka 與 Robert Gentleman 從 S 語言所發展出來, 主要是為了統計分析與統計繪圖. R 除了資料處理與分析, R 擁有一完整陣列和矩陣的操作運算, 完整圖形工具, 也是一種相當完善的程式設計語言. S 語言在 1980 年代末期, 由 AT&amp;T 實驗室, Rick Becker, John Chambers, 與 Allan Wilks 發展用來進行統計分析與統計繪圖, 1990 年代, Insightful 公司將 S 商品化, 並加入許多方便的操作介面, 稱為 Splus. R 與 S (或 Splus) 語法大多相近, R 與 S 都是以物件導向為主的程式語言, 透過交互作用方式很容易地進行統計分析與統計繪圖, 在當年 S 語言使用交互作用方式與當時主流統計軟體, 如 SAS, SPSS 有相當差異. 且最大差別是 R 是一個免費的統計分析軟體 (open-source, GNU General Public License), R 目前由一群跨國際的志工人員組成的 {R} 核心發展組織 (R core-development team) 所維持, 運作與持續更新發展, 在今日, {R} 不僅是統計專業人員的研究工具, 也是資料科學家經常使用的重要工具之一. 1.1 下載與安裝 R R 有各種版本, 可以在 Microsoft Window, Unix/Linux, Apple Mac OS 等作業性系統運行, 以下則以 windows 作業系統為主要說明. 若你的 windows 使用者名稱或帳號為中文, 請先進入控制台, 新增或變更 ``使用者名稱’’ (User), 更改使用者名稱為英文, 然後才進行以下安裝. 任何與 R 的檔案名稱或路徑名稱, 請勿使用中文, 空格或特殊符號. R 與其他軟體成可以形成強大的可重製性研究論文或動態文件 (Reproducible Research, Dynamic Documentation), 可同時依序安裝 Rtools, RStudio, Tex System, Pandoc, Git 等相關軟體. 初學者請請讓軟體內設的路徑 (PATH) 自動安裝, 不要任意更動 PATH 與安裝位置. 安裝任何與 R 相關軟體, 請按滑鼠右鍵以系統管理員身分執行. R 時常有更新版本, 下載與安裝 R 與 Rtools 簡述如下: 1. 上網至 http://www.r-project.org 2. 按滑鼠點選網頁左邊連結 (Link) 下載區 Download CRAN. 3. 按滑鼠點選網頁 CRAN Mirrors 中的任一鏡像網址 (CRAN Mirrors), 如 https://cloud.r-project.org/ 4. 按滑鼠點選上述鏡像網址內網頁中的 Download R for Windows. 5. 按滑鼠點選網頁 R for Windows 中的 base. 6. 按滑鼠右鍵, 點選檔案網址 Download R X.Y.Z for Windows, 其中 X.Y.Z 為 R 版本代碼, 下載儲存至個人檔案夾內. 7. 至下載的檔案夾內, 按滑鼠右鍵點擊 R-X.Y.Z-win.exe, 以系統管理員身分執行安裝. 8. 可選擇中文或英文進行安裝, 只要安裝 64 位元系統. 9. 回到與 base 同一網頁視窗, 點選 Rtools, 點選最先版本的 Rtoolsxx.exe. 下載檔案, 請按滑鼠右鍵以系統管理員身分執行安裝. 10. 詳細安裝 Windows, Mac 或 Linux 作業系統, 利用 google 或 Youtube 等, 搜尋相關訊息. 1.2 下載與安裝 RSudio 直接在 {R} 視窗輸入 {R} 指令並不是很方便. 使用文字編輯軟體輸入, 修正, 儲存, 然後再送到 {R} 執行. 過去有許多 {R} 文字/程式編輯軟體可用, RStudio 是目前最方便的 {R} 編輯程式, RStudio 原始是 {R} 的一種操作介面, 目前也衍伸成可使用多種程式語言的操作介面. 可上網至 http://www.rstudio.com/, 在 Product 選項下, 選擇 R premier IDE for R, 選擇 Rstudio Desktop, 選擇合適的作業系統進行下載 RStudio. 下載 Rstudio 檔案完成後, 請按滑鼠右鍵以系統管理員身分執行安裝. 再次注意, 使用者名稱 (User Name), 須更改使用者名稱為英文, 然後才進行下載安裝. 任何與 RSudio 的檔案名稱或路徑名稱, 請勿使用中文, 空格或特殊符號. 若想使用 Tex/LaTeX, 或 讓 Rstudio 產生 PDF 檔案, 需依序安裝 Tex system, Pandoc, Git, 安裝 TeX/LaTeX/XeLaTex 系統, 請至 https://www.latex-project.org/get/, 或直接安裝 MikTeX: http://miktex.org/. 安裝 Pandoc, 請至 http://pandoc.org/, 或 http://pandoc.org/installing.html. 安裝 Git, 請至 https://git-scm.com/. 同時申請 GitHub 帳號, 任何軟體請按滑鼠右鍵以系統管理員身分執行安裝. 詳細的可重製性研究論文操作, 可參考 (Xie 2015), Xie (2020) https://bookdown.org/yihui/rmarkdown/, https://rmarkdown.rstudio.com/ 等文件. 1.3 簡單實例 學習 {R} 最好的方法, 就是要開始使用 {R}, 初學者要了解 {R}, 可先進行一些簡單實例的演練, 首先須注意的是, 在 {R} 程式語言所使用的文字, 大小寫是有差別的. 直接在 {R} 或 RStudio console 視窗輸入指令都會得到相同的結果. 1+2 # calculator log(3.14) # log function x = 1 + 2 # one plus two assign to x x # print x x = c(1, 3, 5, 7) # get a vector mean(x) # mean function log(x) # log function 若要自學基本 {R} 或 進階 {R}, 利用 google 搜尋 R Introduction, R Tutorial 等, 或搜尋與觀看 YouTube 影片. 請繼續練習下列指令. factorial(4) sin(pi) x.vec &lt;- c(2:5) exp(x.vec) matrix(c(1:6), nrows=2, ncols=3) weight = c(50, 45, 67, 53) mean(weight) sd(weight) {R} 具有強大的繪圖功能, 可將程式語言與繪圖函數緊密結合, 控制標題, 顏色, 說明文字等, 繪製高品質的統計圖並可儲存於不同格式, 提供不同文書處裡軟體使用. 練習以下指令可以體會一些 {R} 的繪圖功能. ## demo demo(graphics) demo(image) example(contour) demo(persp) example(persp3d) demo(plotmath) demo(Hershey) install.packages(&quot;lattice&quot;) # install package library(&quot;lattice&quot;) # load package demo(lattice) example(wireframe) install.packages(&quot;rgl&quot;) library(&quot;rgl&quot;) demo(rgl) # Interact using your mouse. {R} 是統計程式語言, 程式語言是語言的一種, 程式語言是人與電腦溝通的工具, 任命令電腦做事的語言. 程式語言是須嚴謹的邏輯語法, 電腦才會正確執行命令, {R} 對於未有統計專業背景的初學者是困難學習的語言, 初學者學習 {R} 語言, 類似小孩學習語言, 通常須 0.5$$1.0 年以上, 初學者請先直接學習現成實用的簡單指令, 初學者請不要先學太多抽像語法與閱讀抽像說明, 若已經學習其它一種程式語言相對較容學會易另一種程式語言. 學習程式語言最大挫折是城市經常出現無法理解的錯誤訊息, 可利用 google, 將錯誤訊息尋找容易理解的答案. {R} 最常犯的錯誤如下: 英文大小寫差異. 英文單字拚錯. 中文編碼問題, Big5 與 utf-8 等. 缺少標點符號: 單/雙引號, 逗號, $, }, ], ). 變數名/物件名, 指令, 資料檔案: 多餘空白, 多餘空格, 多餘 Tab 等. 直接從 PDF 文件 或 Web 等 copy 程式造成亂碼. 未詳細閱讀錯誤訊息或警告訊息. 初學者對物件命名時, 應盡量避免定義一個物件名字, 與現有的物件同名, 所以命名時要避免重覆, 同時避免物件名字過短, 以免後來引起錯亂. 1.4 物件 Object {R} 與 S 是物件導向為主的程式語言, (Object-Oriented Programming Language), 在 {R} 系統中, 儲存的資料或可執行的函數, 都稱為 物件 (object). {R} 物件包含儲存資料的 向量 (vector), 矩陣 (matrix), 陣列 (array), 列表 (Lists), 資料框架 (data frames) 或執行特定運算指令的 函式 (function) 等. {R} 透過函式或指令, 很容易地對資料物件進行統計分析與統計繪圖. 須特別注意, 在 {R} 對物件或指令命名的英文大小寫是有差異, s 與 S 是不同的. 對物件命名時, 物件名字 (object name) 起始位置必須以 英文字母 或 . (句點) 命名, 若物件名字以 . 為起始, 則物件名字的第二個位置需為文字, 物件名字其餘位置, 以英文字母 (A-Z 或 a-z), 數字 (0-9), /, ., _ (underscore) 或 -, 等皆可. 中間不可有空格. {R} 也保留一些特定名字做為特定的物件名字, 指令名字或常用函式名字使用, 例如, c, s, C, T, F 等, 這些名稱叫做 保留名字 (reserved names). 例如: FALSE Inf NA NaN NULL TRUE break else for function if in next repeat while F T c q s t C D I diff mean pi range rank var 初學者對物件命名時, 應盡量避免定義一個物件名字, 與現有的物件同名, 所以命名時要避免重覆, 同時避免物件名字過短, 以免後來引起錯亂. 1.5 使用指令 {R} 基本介面是一個互動式指令視窗, 指令可分成 2 種, 一為 運算式 (expression), 例如, 1+2 log(x) mean(x) 另一個為 指派運算 或 賦值運算 (assignment), 例如, x &lt;- 1+2 x = 4-5 當一個 {R} 程式需要使用者輸入指令時, 它會顯示 指令提示符號 (prompt symbol), 指令提示符號通常是一個 &gt; (大於符號). 當使用者輸入完整的 運算式, 則運算式指令輸入後的結果, {R} 會馬上顯示在指令下方. 當使用者輸入完整的 指派運算, {R} 同樣會做運算式, 並且把結果 (值) 傳給變數, 但結果不會自動顯示在 {R} 視窗螢幕上. 在 {R} 中可利用 options(prompt = &quot;R&gt;&quot;) 將指令提示符號 &gt; 改成 R&gt;. 指派運算符號 (assignment symbol) 通常是 &lt;- ``, 一個小於符號和一個短線符號組成, 例如,x &lt;- 1 + 2, 讀成x``得到'' $(1 + 2)$. 在 {R} 中可以如傳統的程式語言或統計軟體, 使用=(等號) 為 **指派運算符號**, 例如,x = 1 + 2, 但在 {R} 中,=(等號) 還有其他用途, 使用者可依個人習慣使用&lt;-或=, 但是多數 {R} 專業人士建議使用&lt;-`. 要顯示賦值運算的結果, 可以輸入物件名, 使用函式 print(), 或在賦值運算時, 前後加上小括號顯示賦值運算的結果. ## asign x &lt;- 1 # assign object x x # show x ## [1] 1 print(x) # print() ## [1] 1 msg &lt;- &quot;hello&quot; msg # show x ## [1] &quot;hello&quot; 如果一條輸入的指令在第一行結束的時候, 在 {R} 語法上還不完整, 若用鍵盤上 &lt;Enter&gt; 按鍵時, 則 {R} 會給出另一個不同的提示符號, 通常是 + (加號), 且該提示符號 + 會出現在第二行, 和隨後的數行中, {R} 持續地等待使用者輸入指令. 當一指令在語法上是完整的時候, 使用鍵盤上 &lt;Enter&gt; 按鍵時, {R} 才會執行指令. 不同的完整指令要在同一行輸入時, 可用 ; (分號) 隔開, 或是另起一新輸入行輸入指令分別輸入不同的完整指令. 例如, ## input at the same line, use ; x &lt;- 1 + 2; y &lt;- 3 + 4 ## input 2 lines separately x &lt;- 1 + 2 y &lt;- 3 + 4 數個指令也可以放入一組大括弧內, { \\; }, 數個指令放在一起, 構成一個 複合運算式 (compound expression), 這部份在函式的章節會再進一步說明. 在 {R} 中, 若要對任何指令, 物件, 程式語言 加上 注釋 (commands), 則注釋從 # (井號) 開始, 到句子收尾之間的語句就是是注釋, 在 {R} 中, 注釋幾乎可以放在任何地方的任何一行之中. 習慣上, 整行的注釋使用雙井號作為開始, ##, 運算式尾端注釋使用單井號開始 #. ## This is my R code log(pi) ## [1] 1.14473 ## simple calculation 3+4 # calculator: two plus one ## [1] 7 在 {R} 互動式窗 Console 中, 若要重複一個指令, 或是叫回之前輸入的指令, 可以用鍵盤上的 \\(\\uparrow\\) (向上) 箭頭按鍵, 調出之前已經輸入的指令, 視窗中便可顯示之前的輸入指令, 再利用鍵盤上 &lt;DEL&gt; 按鍵更改成所要輸入的指令. 可以再次練習以下指令, 檢視 {R} 會傳結果. # This is my R code x = 1 + 2 # one plus two x ## [1] 3 x + 4 ## [1] 7 x - 1 ## [1] 2 1.6 查詢顯示物件與刪除物件 在 {R} 中產生和控制的實體稱為 物件 (object), 它們可以是向量, 陣列, 字串, 函式等不同型式. {R} 函式 object() 或 ls() 可以查詢與顯示當前保存在 {R} 環境中的物件名稱. ## show objects object() # shiow all objects ls() # show all obkects ls(x, y) # show x and y object 透過函式 rm(), 可以刪除物件, 例如, ## delete objects: x.vec and y.vec rm(x.vec, y.vec) 可以刪除物件 x.vec 與 y.vec. 1.7 程式中止操作 當程式寫作不當, 造成 {R} 永無止境的執行運算. 若要中斷執行中的程式, 可按下 &lt;Esc&gt; 鍵中斷執行中的程式. 例如, 輸入 for (i in 1:1000000) print (i) # press &lt;Esc&gt; 按下 &lt;Esc&gt; 鍵可中斷執行中的程式. 1.8 工作目錄 任何 {R} 工作中產生的物件或暫時檔案, 都會在電腦的 工作目錄 或 工作路徑 (working directory). {R} 指令內的路徑 (PATH) 分隔為 // (例如, C://RData//) 或 / (例如, C:/RData/). 可用 Windowns 的 \\(\\backslash\\backslash\\) (例如, C:\\(\\backslash\\backslash\\)RData). 指令 getwd(), 可以顯示當前工作目錄. 指令 setwd(), 可以改變當前工作目錄. 請練習以下指令. getwd() # show your current working directory setwd(&quot;C:/RData/&quot;) getwd() ## [1] &quot;C:/RData&quot; 請再比較下列比較檔案路徑格式指令. setwd(&quot;C:/RData&quot;) getwd() setwd(&quot;C:/RData/&quot;) getwd() 使用 {R} 做統計資料分析, 不同的分析資料計畫, 最好使用不同的工作目錄, 以免相同名字的物件, 相互取代, 也便於管理. 在分析資料過程中, 將物件命名為 age, gender, m1.lm, m2.lm 等, 是一件常有的情形, 在任一次的分析計畫中, 這樣的命名是有其特定含義, 但不同分析資料計畫, 在一個工作目錄下進行時, 區別資料內相同物件名字, 是一件非常困難的事情. 此時可以利用 RStudio 專案計畫 (project), 將不同資料分析或課程內容獨立在一個專案計畫, 每一個專案計畫都在同一檔案路徑或檔案夾中, 此時程式便可攜帶任一作業系統或上傳到 GitHub 系統. 詳細的可重製性研究論文操作與版本控制 (version control), 可參考 (Xie 2015), Xie (2020) https://bookdown.org/yihui/rmarkdown/, https://rmarkdown.rstudio.com/, https://happygitwithr.com/ 等文件. 1.9 程式編輯軟體與整合系統 RStudio 若要方便使用中文以及可重製性研究論文系統, 可更動下列選項. 開啟 RStudio: 使用滑數點選 Tools, 點選 Global Options..... 點選 General, 取消點選 Restore .RData, 在 Save workspace to .RData on exit: 點選 Never. 在 Default text encoding: 點選 UTF-8. 點選進入 Appearance, 點選你喜歡的式樣, 例如, 點選 Zoom: 140%, 點選 Font size: 14, 點選你喜歡的字型. 點選進入 Sweave, 在 Waeve Rnw file using: 點選 knitr, 在 Typest LaTeX into PDF using: 點選XeLaTeX`. 最後記得點選 Apply 或 OK. 開始使用 {RStudio} 撰寫第一個 R 程式檔案. 開啟 {RStudio}, 檢視 {RStudio} 在左上角視窗最上端工具列. 點選 File \\(\\rightarrow\\) New File \\(\\rightarrow\\) R Script, 開啟一新的 R 程式檔案. 同樣在左上角視窗最上端工具列, 點選 File, \\(\\rightarrow\\) 存檔案 Save as, 在檔案夾 C:\\(\\backslash\\)RData, 儲存成為 Rlab00.r 檔案. 以 .r 或 .R 為副檔名, 代表 {R} 程式檔案. 在 source 視窗, 輸入以下程式. 輸入完成後, 同樣在左上角視窗最上端工具列, 點選 File, 存檔案 Save. 上述操作部分指令有捷徑可使用. 以下撰寫第一個 R 程式, 並完成存檔. ## Rlab00.r x &lt;- 1 print(x) x msg &lt;- &quot;hello&quot; msg y &lt;- 1:20 y rm(x, msg, y) 將程式輸入在 R 程式檔案內, 將要執行的程式行列, 以滑鼠反白, 複製 (copy) 到 {RSudio} Console 視窗, 執行程式. 可以滑鼠反白, 同時按 &lt;control&gt;+&lt;Enter&gt; 鍵, 執行程式. 使用 {R} 程式檔案, 可保有 {R} 程式, 隨時修正或重複執行. 將下列指令輸入在 {RStudio} 新建立的 Rlab00.r 檔案內. 請再次練習下列指令, 並執行致令, 在 {RSudio} Consol 視窗檢視結果. 開啟 {RStudio}, 檢視 {RStudio} 在左上角視窗最上端工具列. 點選 File \\(\\rightarrow\\) New File, 可嘗試建立 \\(\\rightarrow\\) R Notebook 或是 R Markdown, {RStudio} 會自動建立簡單模板 (template). 可見在區塊 (chunk) 以三個撇號 ```{r} 與尾端三個撇號 ``` 之間 可以撰寫 R 程式. 例如, ```{r} 2.4*3.8 x.vec = rnorm(50) y.vec = rnorm(50) plot(x.vec, y.vec) ``` 使用 R Notebook或是R Markdown的好處是可以將報告文字與統計分析結果, 表格或圖片整合, 不用再 copy $\\rightarrow$ paste 到 word 文件上. 當資料增加或修正, 僅要按下上方knit, 即可再次自動排版產生正確的分析結果, 表格或圖片. 讀者可利用 R Notebook 或是 R Markdown 的模板, 按下上方 knit 檢視生成的報告. 1.10 函式 Function {R} 有許多 函式 (function), 函式是一種物件, 是指令的集合, 執行特定功能或運算工作的指令, 資料整理, 資料分析等, 透過函式, 擴展了 {R} 在程式語言的功能性與便利性. 函式內通常需輸入 引數 (argument). {R} 基本系統 (base) 提供了一部分常用函式, 而更多不同類型的函式, 則由許多不同的學者貢獻到 {R} 系統 (contribution) 中, 這些函數都是用 {R} 程式語言寫成的. 例如, 統計常用函式 mean(), var(), sd(), log() 等. 請練習以下 R 程式. ## function ## function c() = concatenate elements, return a vector x.vec x.vec = c(1:5) x.vec # show x.vec ## [1] 1 2 3 4 5 mean(x = x.vec) # function mean() calculate mean, return a scalar ## [1] 3 var(x = x.vec) # function mean() calculate variance ## [1] 2.5 log(x = x.vec) # take log for all elements in vector x.vec ## [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 一個函式內通常需輸入 引數 (argument) 或是 統計公式, 統計模型, (formals). 引數可以是一個以上, 有些引數一定要輸入, 稱為 必要引數 (required argument), 有些引數可以不用輸入, 稱為 自選引數 (optional argument), 另外一種引數則為 省略引數 (ellipsis argument) 這三種引可以同時存在一個函式內, 引數可以是數值, 文字, 資料框架或 {R} 的任何物件. 例如, 函式 log() 指令: log(x, base = exp(1)) log() 函式在 {R} 內設以自然數為底計算, 其中 x 為必備引數, 使用者必須自行輸入所要計算的數值作為引數值. 而 base = exp(1) 為選擇引數, 若使用者沒有輸入引數值, 函式 log() 內設以自然數 \\(e\\) 為底, 當然, 使用者可以更動底數的設定值, 例如更動為以 \\(2\\) 為底的獨度對數運算, log(x, base = 2). ## log function x.vec &lt;- c(1, 2, 3, 4, 5) log(x = x.vec) ## [1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379 log(x = x.vec, base = 2) ## [1] 0.000000 1.000000 1.584963 2.000000 2.321928 1.11 套件 Packages 特定的統計分析方法許多專用的函式集合成一組. 套件} (package). 許多學者針對特定分析, 寫成專用的 {R} 函式, 學者常將這些特定的統計分析方法專用的函式集合成一組 套件 (package), 例如, survival 套件, 專用來進行存活分析, 例如, 在資料科學上大量使用 tidyverse 套件. {R} 的套件數目一直在快速增加, 個別套件內則有不同的函式. 在 {R} 中, 由一些標準 (基本) 套件構成 base {R}, 包含 {R} 可以進行一些標準統計和繪圖所需的的基本函數, 在任何 {R} 的安裝版本中, 都會被自動安裝與載入. 另外, 許多學者為 {R} 提供了基本套件以外的套件, 稱為 貢獻套件 (contributed package). 若在 {R} 第一次使用某一特定功能的套件, 則需事先安裝此特定套件. 安裝套件有不同的方法, 若已經先連接網際網路, 常用的方法為 (1) 使用 {RStudio} 內設套件所在的位置. 由 {RStudio} 右下套件視窗. 使用滑鼠選擇 Packages \\(\\rightarrow\\) Install. 輸入所要安裝的套件名稱, 例如, tidyverse, MASS 等. 使用函式 install.packages() 安裝所需的套件. install.packages(&quot;PackageName&quot;, dependencies = TRUE) 可以安裝 PackageName` 套件. 例如, 可將下列指令寫入 `Console 視窗內. install.packages(&quot;survival&quot;) library(survival) 若在 {R} 中, 要使用某一特定的套件, 須先載入此特定的套件, 請先確認已經安裝套件或更新套件. 使用 library() 或 require() 函式載入套件. 通常建議使用 library(), 因為 library() = loads a package, 會同時檢視套件與關聯的函式是否安裝妥當, 而 require() = tries to load a package, 且當套件與關聯的函式未安裝妥當時, 並不會提出警告或出現 error 訊息, 例如, 函式 foo() 在套件 paa 未先安裝或使用妥當, 使用 require() 納入套件 pbb, 套件 pbb 的函式 coo() 會呼叫 物件函式 foo(), 但使用者並未先納入套件 paa 執行套件 paa 其他程式不會提出警告, 但當使用者在後續使用到函式 coo() 時, 才會出現 error 訊息, 或是不出現 error 訊息而出現產生的物件, my.obj, 不存在, 因此很難追尋到錯誤來源. 通常在使用 library(package.name) 之後, 就可直接使用 package.name 套件內的函式 function.name(). 個別套件內有許多函式, 不同套件可能有相同名稱的函式, 若要避免誤用相同名稱的函式, 可以使用 {::} 串聯 package.name 與 function.name() 如下: package.name::function.name() 就可正確使用特定套件 package.name 內的特定函式 function.name(). 例如使用指令 ggplot2::ggplot() 明確指出使用套件 ggplot2 內的函式 ggplot(). 1.12 解說與輔助文件 {R} 有良好的解說文件, 可利用 Google 搜尋任何 {R} 相關疑惑. {R} 內部最常使用的線上協助為啟動網頁流覽器 help.start(). 嘗試在 Console 輸入 help.start() 尋找特定函式 funName 解說, 在 {R} 中可直接輸入下列任一種函式, help(funName), ?funName, help.search(\"funName\"), apropos(\"funName\") 等等. 例如, 尋找 函式 mean() 函式解說. 在 {R} 中可直接輸入下列任一種指令. help(mean) ?mean help.search(&quot;mean&quot;) apropos(&quot;mean&quot;) 若要詢問函式內的引數, 可用函式 args(\"funName\"). 1.13 地區語系與時區 {R} 程式版本經常更新, 且 {R} 一些貢獻套件也經常在 {R} 版本更新後無法運作, {R} 一些貢獻套件對地區語系與時區的呈現文字非常敏感, 因此在牽涉到不同時區的時間計算與轉換, 可注意使用中 {R} 的地區語系與時區. 函式 sessionInfo() 可以取得使用中 {R} 的所有資訊. sessionInfo() 從函式 version() 可以看見 {R} 版本 version[['version.string']], 從函式Sys.getlocale() 可以看見 {R} 目前設定地區語系為 LC_COLLATE=Chinese (Traditional)_Taiwan.950;LC_CTYPE=Chinese (Traditional)_Taiwan.950;LC_MONETARY=Chinese (Traditional)_Taiwan.950;LC_NUMERIC=C;LC_TIME=Chinese (Traditional)_Taiwan.950. 這是設定台灣地區使用 cp950 (big5) 編碼. 對一些套件可能無法正確顯式. 從函式Sys.timezone() 可以看見 {R} 目前設定時區為 Asia/Taipei. {R} 在台灣當地時間 (local time) 中文格式有時會出現 NA, 一些地區中文的介面對於如何呈現日期時間有時會出現錯誤, 若日期時間輸入輸出格式出現錯誤, 可先改正輸入輸出格式, 例如, 改用英文標準時間 Sys.setlocale(\"LC_TIME\", \"C\"), 如此改成 UTC 時區 (Universal Time, Coordinated). 或是使用 ISO 時間格式. 若要更動語系可使用 # 中文 -&gt; 英文 Sys.setlocale(&quot;LC_CTYPE&quot;, &quot;en_US.UTF-8&quot;) # system(&quot;defaults write org.R-project.R force.LANG en_US.UTF-8&quot;) # linux/mac # 英文 -&gt; 中文 Sys.setlocale(category = &quot;LC_ALL&quot;, locale = &quot;cht&quot;) # system(&quot;defaults write org.R-project.R force.LANG zh_TW.UTF-8&quot;) # linux/mac 上述方式暫時有效, 重新啟動 {R} 後此設定就會消失. References "],
["向量-vector.html", "Chapter 2 向量 Vector 2.1 向量 Vector 2.2 向量基本資料類型 2.3 向量基本運算操作符號 2.4 向量基本算數操作 2.5 向量關係比較操作 2.6 向量元素命名 2.7 向量下標與索引 Inxex 2.8 遺失值 (缺失值) Missing Values 2.9 因子物件與類別變數 Factor", " Chapter 2 向量 Vector {R} 是以物件導向為主的程式語言, 在 {R} 中, 資料或運算指令以具有名稱的 物件 (object), 形式儲存, 資料物件可以是 向量 (vector), 矩陣 (matrix), 陣列 (array), 列表 (Lists), 或 資料框架 (data frames) 等. 在 {R} 中, 資料分析基本上是產生資料物件, 對物件命名, 使用函式對物件運算操作. 透過指令, 很容易地對物件進行統計分析與統計繪圖. {R} 的資料結構與程式寫作相對於目前當紅的其他程式語言較多嚴謹的要求, 本章主要說明 {R} 的基本資料型式與基本運算. 2.1 向量 Vector {R} 的最基本物件是向量, 向量 是指包含相同 模式 (mode) 的元素組成. {R} 的基本資料型式稱為 基本模式 (basic mode) 有 numeric, integer, logical, complex, character. 同一向量內的元素不可混合. 單一數值 (scalar), 可視為僅具有單一元素的向量, 標準的向量是 倍精準度 (double) 的 數值向量 ({numerical vector}). 向量是具有相同基本類型的元素序列, 在 {R} 中, 純量或單一數值 (scalar) 也可看成是長度為 \\(1\\) 的向量, 向量大體上相當於其他程式語言中的 \\(1\\)-維度數列, 但在 {R} 中向量並不具有 沒有維度 (no dimension). 例如, 在 {R} 中 x.vec &lt;- c(1, 2, 3), 可以視為 \\(1 \\times 3\\) 的矩陣, 也可以視為 \\(3 \\times 1\\) 的矩陣, 但是, 當向量 x.vec 與其它向量/矩陣進行運算時, 向量 x.vec 會受到與其進行運算的矩陣物件影響, 若任由 {R} 的內在設定, 則常會有意想不到的運算結果. 2.2 向量基本資料類型 {R} 的最基本物件是向量, 向量 是指包含相同 模式 (mode) 的元素組成. {R} 的基本資料型式稱為 基本模式 (basic mode) 有 numeric, integer, logical, complex, character, 使用函式 class() 可以檢視基本模式. numeric, 數值型 (實數型), 含 single 單精準度型與 double 倍精準度型. # numeric x1 &lt;- 10.1 x1 ## [1] 10.1 class(x1) ## [1] &quot;numeric&quot; x2 &lt;- 10 x2 ## [1] 10 class(x2) ## [1] &quot;numeric&quot; is.numeric(x2) ## [1] TRUE integer, 整數向量 (有時需特別指定輸入成 1L, 2L, …). # integer y1 &lt;- 1L y1 ## [1] 1 class(y1) ## [1] &quot;integer&quot; is.integer(y1) ## [1] TRUE is.numeric(y1) ## [1] TRUE logical, 邏輯型或布林型 (true or false), 以 TRUE (T) 或 FALSE (F) 呈現, 也可以是 \\(1\\) 與 \\(0\\) 整數分別代表 T 與 F. # logic yes_id &lt;- TRUE yes_id ## [1] TRUE no_id &lt;- FALSE no_id ## [1] FALSE class(no_id) ## [1] &quot;logical&quot; is.logical(no_id) ## [1] TRUE 2 == 3 ## [1] FALSE 2 != 3 ## [1] TRUE 2 &gt; 3 ## [1] FALSE 2 &lt;= 3 ## [1] TRUE 4 &gt;= 1 ## [1] TRUE TRUE + 5 ## [1] 6 TRUE * 5 ## [1] 5 FALSE * 5 ## [1] 0 TRUE + FALSE ## [1] 1 TRUE * FALSE ## [1] 0 complex, 複數型. x = 3+5i x ## [1] 3+5i class(x) ## [1] &quot;complex&quot; character, 文字型或字串型, 通常輸入時在文字兩側加上雙引號 (\"). # character ca &lt;- &quot;yes&quot; ca ## [1] &quot;yes&quot; cb &lt;- &quot;this is a book.&quot; cb ## [1] &quot;this is a book.&quot; class(cb) ## [1] &quot;character&quot; is.character(cb) ## [1] TRUE &quot;abc&quot; &gt; &quot;abd&quot; ## [1] FALSE &quot;date&quot; &lt; &quot;dates&quot; ## [1] TRUE 資料分析另外常見的日期與類別變數也必須特別處裡. 格式有 ’Date,POSIXct與POSIXt等, 例如, 使用函式Sys.Date()` 可得系統日期. Sys.Date() ## [1] &quot;2020-09-12&quot; date1 &lt;- as.Date(&quot;2020-09-17&quot;) date1 ## [1] &quot;2020-09-17&quot; class(date1) ## [1] &quot;Date&quot; as.numeric(date1) ## [1] 18522 date2 &lt;- as.POSIXct(&quot;2020-09-17 18:30&quot;) class(date2) ## [1] &quot;POSIXct&quot; &quot;POSIXt&quot; as.numeric(date2) ## [1] 1600338600 詳細的日期與類別變數操作, 以後再詳述. 2.2.1 向量產生函式 c() 輸入簡單的向量資料, 可以用函式 c() 指令. c()為 concatenate (連接), 將數值或文字連接成向量. ## c() ## numerical x.vec &lt;- c(1/1, 1/2, 1/3, 1/4, 1/5) x.vec ## [1] 1.0000000 0.5000000 0.3333333 0.2500000 0.2000000 ## integer x.vec &lt;- c(1L, 2L, 3L) x.vec ## [1] 1 2 3 ## character flavors.vec &lt;- c(&quot;chocolate&quot;, &quot;vanilla&quot;, &quot;strawberry&quot;) # character flavors.vec ## [1] &quot;chocolate&quot; &quot;vanilla&quot; &quot;strawberry&quot; y.vec &lt;- c(&quot;Hello&quot;, &quot;What&#39;s your name?&quot;, &quot;Your email?&quot;) y.vec ## [1] &quot;Hello&quot; &quot;What&#39;s your name?&quot; &quot;Your email?&quot; ## logical z.vec &lt;- c(F, T, T, F, F) z.vec ## [1] FALSE TRUE TRUE FALSE FALSE ## complex x.complex.vec &lt;- c(8+3i, 9+0i, 2+4i) x.complex.vec ## [1] 8+3i 9+0i 2+4i ## numerical x.vec &lt;- c(1/1, 1/2, 1/3, 1/4, 1/5) y.vec &lt;- c(1, 2, 3, 4, 5) z.vec &lt;- c(x.vec, 11, 12, y.vec) z.vec ## [1] 1.0000000 0.5000000 0.3333333 0.2500000 0.2000000 11.0000000 12.0000000 ## [8] 1.0000000 2.0000000 3.0000000 4.0000000 5.0000000 2.3 向量基本運算操作符號 {R} 對物件運算操作有其 基本操作符號 (basic operators), 如同 C 語言, 可以分成算數操作 (arithmetic operator), 相關比較操作 (relation/comparison operator), 邏輯操作 (logical operator). {R} 也是一種高階程式語言 (programming language), 因此提供了其它程序語言共有的 條件 (if-else), 轉換 (switch), 迴圈 (loop) 與 函式 (function) 等, 程序控制結構語法, 進階資料分析使用高階程式語言與函式寫作進行. 本章先討論基本運算操作. 向量基本運算操作符號 符號 定義 - 減法運算 (Substraction, can be unary or binary) + 加法運算 (Addition, can be unary or binary) ! 否定運算 (Unary not) * 乘法運算 (Multiplication, binary) / 除法運算 (Division, binary) ^ 指數乘冪運算 (Exponentiation, binary) %% 整數除法的餘數 (Modulus, binary) %/% 整數除法的商數 (Integer divide, binary) %*% 矩陣內積乘法 (Matrix product, binary) %o% 矩陣外積乘法 (Outer product, binary) %x% 矩陣 Kronecker 乘法 (Kronecker product, binary) %in% 配對運算 (Matching operator, binary, in model formulae: nesting) &lt; 小於 Less than, binary &gt; 大於 Greater than, binary == 相等 Equal to, binary != 不相等 Not equal to &gt;= 大於或等於 Greater than or equal to, binary &lt;= 小於或等於 Less than or equal to, binary &amp; 邏輯 和, 向量的個別元素使用 (Logical AND, binary, vectorized) &amp;&amp; 邏輯 和, 二元操作 (Logical AND, binary, not vectorized) | 邏輯 或, 向量的個別元素使用 (Logical OR, binary, vectorized) || 邏輯 或, 二元操作 (Logical OR, binary, not vectorized) xor 邏輯 ``或’’, 向量個別元素互斥聯集運算, 僅有 1 為 TRUE 2.4 向量基本算數操作 {R} 向量物件的 算數操作 (arithmetic operator) 符號包含以下符號, +, -, !, *, /, \\^, %%, %/%, %*%, %o%, %x%, %in% 等 算數操作根據最基本的運算次序: 括號, 指數, 乘法, 除法, 加減法, 也就是如同一般手寫計算. ## Arithmetic Operator 1 + 2 ## [1] 3 1 + 2 + 3 ## [1] 6 3 * 7 * 2 ## [1] 42 4/2 ## [1] 2 4/3 ## [1] 1.333333 2 * 3 + 4 ## [1] 10 2 * (3 + 4) ## [1] 14 (3 + 11 * 2)/4 ## [1] 6.25 # x.complex &lt;- (8+3i)+(1+2i) x.complex ## [1] 9+5i # x.vec &lt;- 1:5 y.vec &lt;- c(-1, -2, 0, 2, 4) z.vec &lt;- c(2, 2, 3, 3, 4) x.vec + y.vec ## [1] 0 0 3 6 9 x.vec - y.vec ## [1] 2 4 3 2 1 # x.vec * 2 ## [1] 2 4 6 8 10 x.vec * y.vec ## [1] -1 -4 0 8 20 x.vec/2 ## [1] 0.5 1.0 1.5 2.0 2.5 x.vec/y.vec ## [1] -1.00 -1.00 Inf 2.00 1.25 # x.vec^2 ## [1] 1 4 9 16 25 x.vec^z.vec ## [1] 1 4 27 64 625 y.vec/2 ## [1] -0.5 -1.0 0.0 1.0 2.0 y.vec/x.vec ## [1] -1.0 -1.0 0.0 0.5 0.8 # y.vec %% 3 # modular arithmetic remainder ## [1] 2 1 0 2 1 y.vec %/% 3 # integer division ## [1] -1 -1 0 0 1 y.vec %/% x.vec ## [1] -1 -1 0 0 0 2.5 向量關係比較操作 邏輯向量 (logic vector) 的元素值有 TRUE, FALSE. 可以分別簡寫為 T 和 F. 在 {R} 之內, 向量之間的 關係比較操作 (relation/comparison operator) 可以產生邏輯向量. 關係比較操作符號包含常見的 &lt;, &lt;=, &gt;, &gt;=, &amp;, &amp;&amp; (AND), | , || (OR), 以及判斷相等的 == 和判斷不等的 != 等. ## Relation/Comparison Operator x.vec &lt;- 1:5 y.vec &lt;- (x.vec &gt; 2) y.vec ## [1] FALSE FALSE TRUE TRUE TRUE any(x.vec &gt; 2) ## [1] TRUE all(x.vec &gt; 2) ## [1] FALSE # x.vec &lt;- 1:5 y.vec &lt;- c(0, 2, 4, 6, 8) # x.vec &lt; 2 ## [1] TRUE FALSE FALSE FALSE FALSE x.vec&lt;= 2 ## [1] TRUE TRUE FALSE FALSE FALSE x.vec == 2 ## [1] FALSE TRUE FALSE FALSE FALSE x.vec != 2 ## [1] TRUE FALSE TRUE TRUE TRUE # x.vec &lt; y.vec ## [1] FALSE FALSE TRUE TRUE TRUE x.vec &lt; (y.vec - 2) ## [1] FALSE FALSE FALSE FALSE TRUE x.vec &lt;= y.vec ## [1] FALSE TRUE TRUE TRUE TRUE x.vec &lt;= (y.vec - 2) ## [1] FALSE FALSE FALSE TRUE TRUE # x.vec == y.vec ## [1] FALSE TRUE FALSE FALSE FALSE x.vec == (y.vec - 2) ## [1] FALSE FALSE FALSE TRUE FALSE x.vec != y.vec ## [1] TRUE FALSE TRUE TRUE TRUE x.vec != (y.vec - 2) ## [1] TRUE TRUE TRUE FALSE TRUE # ## Logical Operator: AND OR XOR x.vec &lt;- 1:5 y.vec &lt;- c(0, 2, 4, 6, 8) (x.vec &gt; 0) &amp; (y.vec &gt; 0) # return vector AND ## [1] FALSE TRUE TRUE TRUE TRUE (x.vec &gt; 0) &amp;&amp; (y.vec &gt; 0) # return scalar AND ## [1] FALSE # (x.vec &gt; 0) &amp; ((y.vec - 3) &gt; 0) # return vector AND ## [1] FALSE FALSE TRUE TRUE TRUE ((x.vec-2) &gt; 0) &amp;&amp; ((y.vec - 3) &gt; 0) # return scalar AND ## [1] FALSE # (x.vec &gt; 0) &amp; ((y.vec + 3) &gt; 0) # return vector AND ## [1] TRUE TRUE TRUE TRUE TRUE ((x.vec-2) &gt; 0) &amp;&amp; ((y.vec + 3) &gt; 0) # return scalar AND ## [1] FALSE # (x.vec &gt; 0) | (y.vec &gt; 0) # return vector OR ## [1] TRUE TRUE TRUE TRUE TRUE ((x.vec- 2) &gt; 0) | ((y.vec - 3) &gt; 0) ## [1] FALSE FALSE TRUE TRUE TRUE # (x.vec &gt; 0) || (y.vec &gt; 0) # return scalar OR ## [1] TRUE ((x.vec-2) &gt; 0) || ((y.vec - 3) &gt; 0) ## [1] FALSE # (x.vec &gt; 0) || ((y.vec + 3) &gt; 0) # return scalar OR ## [1] TRUE ((x.vec-2) &gt; 0) || ((y.vec + 3) &gt; 0) ## [1] TRUE # xor((x.vec &gt; 0), (y.vec &gt; 0)) # return vector exclusive OR ## [1] TRUE FALSE FALSE FALSE FALSE xor(((x.vec - 2) &gt; 0), ((y.vec - 3) &gt; 0)) ## [1] FALSE FALSE FALSE FALSE FALSE xor(((x.vec - 2) &gt; 0), ((y.vec + 3) &gt; 0)) ## [1] TRUE TRUE FALSE FALSE FALSE # xx.vec &lt;- (x.vec &lt;= 3) yy.vec &lt;- (y.vec &gt;= 4) xx.vec ## [1] TRUE TRUE TRUE FALSE FALSE yy.vec ## [1] FALSE FALSE TRUE TRUE TRUE # xx.vec &amp;&amp; yy.vec ## [1] FALSE xx.vec &amp; yy.vec ## [1] FALSE FALSE TRUE FALSE FALSE xx.vec || yy.vec ## [1] TRUE xx.vec | yy.vec ## [1] TRUE TRUE TRUE TRUE TRUE xor(xx.vec, yy.vec) ## [1] TRUE TRUE FALSE TRUE TRUE 2.6 向量元素命名 向量的每個元素或部分元素都可以命名, 使用者可以在輸入元素時直接給予命名, 或另外使用函式 names() 給予命名. 若要移除命名, 使用函式 unname() 移除命名, 或使用 names(x.vec) &lt;- NULL 移除命名. ## vector names x.vec &lt;- c( age = 50, chol = 220, dbp = 84, sbp = 132 ) # directly x.vec ## age chol dbp sbp ## 50 220 84 132 names(x.vec) ## [1] &quot;age&quot; &quot;chol&quot; &quot;dbp&quot; &quot;sbp&quot; # x.vec &lt;- c(55, 236, 80, 140) names(x.vec) &lt;- c(&quot;age&quot;, &quot;chol&quot;, &quot;sbp&quot;, &quot;dbp&quot;) # y.vec.name &lt;- names(x.vec) y.vec &lt;- c(60, 214, 90, 144) names(y.vec) &lt;- y.vec.name y.vec ## age chol sbp dbp ## 60 214 90 144 2.7 向量下標與索引 Inxex 一個向量的長度 (length) 是向量元素的數目, 一個向量的個別元素或部分元素可以向量的下標 (index) 取得, 向量的 下標 或 索引 (index) 是在向量名稱後面加 中括號 [i], 並放入下標數目 (或向量) 得到. 原始向量的下標可以採用下列四種方式的任何一種, 正整數, 負整數, 文字或字串與邏輯向量. ## Vector Indexing ## positive integer x.vec &lt;- 1:50 x.vec[7] ## [1] 7 x.vec[11:15] ## [1] 11 12 13 14 15 y.vec &lt;- x.vec[11:15] y.vec ## [1] 11 12 13 14 15 ## negative integer z.vec &lt;- 6:10 z.vec[-c(2, 4)] ## [1] 6 8 10 ## character string fruit.vec &lt;- c(5, 10, 1, 20) fruit.vec ## [1] 5 10 1 20 names(fruit.vec) &lt;- c(&quot;orange&quot;, &quot;banana&quot;, &quot;apple&quot;, &quot;peach&quot;) fruit.vec ## orange banana apple peach ## 5 10 1 20 lunch.vec &lt;- fruit.vec[c(&quot;apple&quot;, &quot;orange&quot;)] lunch.vec ## apple orange ## 1 5 ## logical index x.vec &lt;- c(NA, -2, -1, NA, 1, 2, NA) # NA = missing value x.vec ## [1] NA -2 -1 NA 1 2 NA y.vec &lt;- x.vec[!is.na(x.vec)] # !is.na() = check missing value y.vec ## [1] -2 -1 1 2 z.vec &lt;- x.vec[x.vec &gt; 0 &amp; !is.na(x.vec)] z.vec ## [1] 1 2 x.vec[x.vec &lt; 0] # Note: NA ## [1] NA -2 -1 NA NA y.vec[y.vec &lt; 0] ## [1] -2 -1 z.vec[z.vec &lt; 0] ## numeric(0) 2.8 遺失值 (缺失值) Missing Values 研究資料, 通常會有 遺失值 或 缺失值 (missing value, incomplete data**), 在 R 中, 輸入或輸出遺失值, 通常以 NA 表示, (NA = Not Available), R 還有另外有 NaN = Not a Number 是指物件運算後產生非數值結果, 以及 NULL 是指物件的長度是 \\(0\\). 任何對遺失值 (NA) 的算數操作, 會得到遺失值 (NA) 結果. 使用函式 is.na(), is.nan() 可以查看向量內那些元素是遺失值. 回傳一個邏輯向量. 對遺失值作比較大小運算須非常小心. 要移除遺失值, 可以使用函式 na.omit(), na.fail(), na.exclude(), na.action() 等指令. 且函式 complete.cases() 可以同時移出多個缺失值. 對於不同基本模式的向量元素進行融合, 若不合階層結構, 則 R 回傳缺失值. ## missing value z.vec &lt;- c(1:2, NA) is.na(z.vec) ## [1] FALSE FALSE TRUE log(z.vec) ## [1] 0.0000000 0.6931472 NA z.vec / 0 ## [1] Inf Inf NA 0 / 0 ## [1] NaN Inf - Inf ## [1] NaN # is.na(z.vec) ## [1] FALSE FALSE TRUE is.nan(z.vec) ## [1] FALSE FALSE FALSE is.nan(0 / 0) ## [1] TRUE # x.vec &lt;- c(1, 2, NA, 4, NA, 5, 6) bad &lt;- is.na(x.vec) x.vec[!bad] ## [1] 1 2 4 5 6 # x.vec &lt;- c(1, 2, NA, 4, NA, 5, 6) y.vec &lt;- c(&quot;a&quot;, &quot;b&quot;, NA, &quot;d&quot;, NA, &quot;f&quot;, &quot;g&quot;) good &lt;- complete.cases(x.vec, y.vec) good ## [1] TRUE TRUE FALSE TRUE FALSE TRUE TRUE x.vec[good] ## [1] 1 2 4 5 6 y.vec[good] ## [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; # data(airquality) airquality[1:6,] ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 5 NA NA 14.3 56 5 5 ## 6 28 NA 14.9 66 5 6 good &lt;- complete.cases(airquality) airquality[good,][1:6,] ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 7 23 299 8.6 65 5 7 ## 8 19 99 13.8 59 5 8 2.9 因子物件與類別變數 Factor 因子物件 (factor) 為處理 類別資料 (categorical data), 提供的一種有效的方法. 類別變數 將變數值分成互斥的類別水準, 在類別變數定義中的特定幾種類別水準是否有大小差距, 又可分類成 名目變數 (nominal variable) 與 有序變數 (ordinal variable), 或稱 名目尺度 與 順序尺度. 其中 名目尺度 是最簡單的測量, 名目尺度將變數值分成互斥的類別水準, 同一變數內的類別水準並無量化大小的差別. 名目尺度用文字或數字表示或標記, 這些數字本身並無任何意義, 例如 左側 為 1, 右側 為 0; 1 \\(=\\) 拇指, 2 \\(=\\) 食指, 3 \\(=\\) 中指, 4 \\(=\\) 無名指, 5 \\(=\\) 小指. 在名目尺度中, 特別的情形是變數內只有 2 個類別水準, 如存活或死亡, 統計習慣上會分別標記為 0 或 1, 感染或無感染, 這類變數常稱做 二元變數 (dichotomous variable, binary variable), 二元變數通常有特殊的統計分析方法. 順序尺度 是指同一變數內的類別水準有 輕重, 大小, 強弱, 好壞等級順序之資料. 例如, 疼痛情形有 4 種情境: 無, 輕度, 中度, 重度, 癌症分期為 I, II, III, IV 等 4 期. 雖然順序尺度用數字 \\(1, 2, 3, 4, \\ldots\\) 表示或標記, 但是數字本身通常不能用來做運算, 只能比較相對大小或高低次序, 順序之間的實際差異並無法從標記的數字差異得知. 統計中的類別資料, 有各種不同表示方法, 在電腦的資料儲存時常常是以文字為變數值, 但使用上文字較占空間且無法精準傳達 類別變數的概念. 因此在 {R} 中特別使用 因子 (factor) 來表示. 因子是一種特殊的文字向量, 文字向量中的每一個元素, 取一個離散值, 因子物件 有一個特殊屬性, 稱為 **層次*, **水平*, **水準* 或 類別水準 (levels), 表示這組所有可能的離散值. 因子常常是用文字或字串輸入, 有時會使用數值或整數代表, 一但變數設定為因素或因子向量, {R} 在列印或輸出時, 並不會加上雙引號 \", 且數值或有大小順序的文字, {R} 在統計分析上都必須特別處理. 在 {R} 中若要設定因子, 可以簡單地用函式 factor() 產生無序因子物件. factor(x = character(), levels, labels = levels, exclude = NA, ordered = is.ordered(x), nmax = NA) 其中引數為 x 為原始向量, 通常為文字向量, 若是數值向量, {R} 先轉換成文字向量. levels 設定類別水準. labels 類別水準的標記文字. exclude = NA 排除缺失值或某一特定值為一類別水準. ordered = is.ordered(x) 設定因子物件類別水準的順序, 仍是無序因子物件. nmax = NA 是否類別水準的最大數目. ## factor() sex &lt;- c(&quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;) sex ## [1] &quot;male&quot; &quot;female&quot; &quot;male&quot; &quot;male&quot; &quot;female&quot; class(sex) ## [1] &quot;character&quot; sex &lt;- factor(sex) sex ## [1] male female male male female ## Levels: female male class(sex) ## [1] &quot;factor&quot; ## factor() + levels sex &lt;- c(&quot;male&quot;, &quot;female&quot;, &quot;male&quot;, &quot;male&quot;, &quot;female&quot;) sex &lt;- factor(sex, levels = c(&quot;female&quot;, &quot;male&quot;)) sex ## [1] male female male male female ## Levels: female male ## factor() + levels + labels x.chr = c(&quot;male&quot;, &quot;male&quot;, &quot;female&quot;, &quot;female&quot;) factor(x.chr, levels = c(&quot;male&quot;, &quot;female&quot;, &quot;bisex&quot;)) ## [1] male male female female ## Levels: male female bisex factor(x.chr, levels = c(&quot;male&quot;, &quot;female&quot;, &quot;bisex&quot;), labels = c(&quot;m&quot;, &quot;f&quot;, &quot;b&quot;)) ## [1] m m f f ## Levels: m f b ## factor() + exclude ## factor() + exclude pain &lt;- c(&quot;none&quot;, &quot;mild&quot;, &quot;moderate&quot;, &quot;severe&quot;, NA) factor(pain) # NA is NOT a level. ## [1] none mild moderate severe &lt;NA&gt; ## Levels: mild moderate none severe factor(pain, exclude = NA) # NA is NOT a level. ## [1] none mild moderate severe &lt;NA&gt; ## Levels: mild moderate none severe factor(pain, exclude = c(NA)) # NA is NOT a level. ## [1] none mild moderate severe &lt;NA&gt; ## Levels: mild moderate none severe factor(pain, exclude = NULL) # NA is a level. ## [1] none mild moderate severe &lt;NA&gt; ## Levels: mild moderate none severe &lt;NA&gt; factor(pain, exclude = &quot;mild&quot;) # NA is a level. ## [1] none &lt;NA&gt; moderate severe &lt;NA&gt; ## Levels: moderate none severe &lt;NA&gt; pain &lt;- factor(pain, exclude = c(&quot;mild&quot;, NA)) pain # mild and NA are NOT levels. ## [1] none &lt;NA&gt; moderate severe &lt;NA&gt; ## Levels: moderate none severe {R} 中的 factor() 為 無序因子 (unordered factor), 類似於統計分析中的 名義變數 (nominal variable), 無序因子 中的類別水準 (level), 其離散值無大小順序的關係, 如性別的男與女. {R} 列印無序因子物件時, 類別水準 內建型式依照文字字母順序, 可以使用函式 levels() 查看無序因子物件的類別水準; 也可以使用函式 levels() 設定列印無序因子物件 類別水準 的顯示次序, {R} 內建顯示次序是依照文字字母或數字排次序, 可以使用函式 levels() 指令, 改變顯示因子物件的次序或方向. 在統計模型中常使用 類別變數 作為解釋變數, 常常必須令 無序因子物件 或 類別變數 的某一個類別水準為 參照水準 (reference level), 以便建構類別型解釋變數內不同類別水準的 對照比較 (contrast comparison). 使用函式 relevel(), 可以改變無序因子類別水準的參考水準. ## unorder ## level() gender &lt;- c(&quot;M&quot;, &quot;F&quot;, &quot;M&quot;, &quot;M&quot;, &quot;F&quot;) gender &lt;- factor(gender) gender ## [1] M F M M F ## Levels: F M levels(gender) ## [1] &quot;F&quot; &quot;M&quot; levels(gender) &lt;- c(&quot;Female&quot;, &quot;Male&quot;) gender ## [1] Male Female Male Male Female ## Levels: Female Male hypertension &lt;- c(&quot;Lo&quot;, &quot;Mod&quot;, &quot;Hi&quot;, &quot;Mod&quot;, &quot;Lo&quot;, &quot;Hi&quot;, &quot;Lo&quot;) hypertension &lt;- factor(hypertension) hypertension ## [1] Lo Mod Hi Mod Lo Hi Lo ## Levels: Hi Lo Mod # relevel() relevel(hypertension, ref = &quot;Lo&quot;) # reset a reference level ## [1] Lo Mod Hi Mod Lo Hi Lo ## Levels: Lo Hi Mod 使用 as.integer() 可將類別變數轉換成數值整數, 此數值整數從 1 到 類別水準的整數, 且依照原有的類別水準依序給整數, 使用上必須注意此差異. ## convert to numerical values hypertension &lt;- c(&quot;Lo&quot;, &quot;Mod&quot;, &quot;Hi&quot;, &quot;Mod&quot;, &quot;Lo&quot;, &quot;Hi&quot;, &quot;Lo&quot;) hypertension &lt;- factor(hypertension) levels(hypertension) ## [1] &quot;Hi&quot; &quot;Lo&quot; &quot;Mod&quot; hypertension ## [1] Lo Mod Hi Mod Lo Hi Lo ## Levels: Hi Lo Mod as.integer(hypertension) ## [1] 2 3 1 3 2 1 2 # levels(hypertension) &lt;- list(&quot;Low&quot; = &quot;Lo&quot;, &quot;Moderate&quot; = &quot;Mod&quot;, &quot;High&quot; = &quot;Hi&quot;) hypertension ## [1] Low Moderate High Moderate Low High Low ## Levels: Low Moderate High as.integer(hypertension) ## [1] 1 2 3 2 1 3 1 # ## convert to numerical values pain &lt;- c(7, 8, 6, 6, 8, 7) pain &lt;- factor(pain) pain ## [1] 7 8 6 6 8 7 ## Levels: 6 7 8 as.integer(pain) ## [1] 2 3 1 1 3 2 pain.chr = as.character(pain) pain.chr ## [1] &quot;7&quot; &quot;8&quot; &quot;6&quot; &quot;6&quot; &quot;8&quot; &quot;7&quot; pain.num = as.integer(pain.chr) pain.num ## [1] 7 8 6 6 8 7 "],
["多維度資料物件.html", "Chapter 3 多維度資料物件 3.1 矩陣物件 Matrix 3.2 矩陣的下標與索引 Matrix Index 3.3 列表物件 List 3.4 資料框架 Data Frame 3.5 資料框架函式 data.frame()", " Chapter 3 多維度資料物件 {R} 是以物件導向為主的程式語言, 在 {R} 中, 資料或運算指令以具有名稱的 物件 (object), 形式儲存, 資料物件可以是 向量 (vector), 矩陣 (matrix), 陣列 (array), 列表 (Lists), 或 資料框架 (data frames) 等. 在 {R} 中, 資料分析基本上是產生資料物件, 對物件命名, 使用函式對物件運算操作. 透過指令, 很容易地對物件進行統計分析與統計繪圖. 上一章討論向量的基本操作, 本章進一步討論 {R} 的其他多維度資料物件, 包含 矩陣 (matrix), 陣列 (array), 列表 (Lists), 或資料框架 (data frames) 等. 3.1 矩陣物件 Matrix 矩陣 (matrix) 物件由包含相同的元素 (模式, mode) 組成的 \\(2\\)-維度 (2-dimension) 資料物件, 矩陣具有 維度 (dimension) 之屬性, 可以使用函式 dim() 檢視. 可以將矩陣視為一個向量具二維結構, 也可以將 矩陣 視為一個向量具 \\(2\\)-維度的陣列 (array). 3.1.1 矩陣函式 matrix() 使用者若要輸入一個簡單的矩陣資料, 列 \\(\\times\\) 欄 (列 \\(\\times\\) 行), 或希望以矩陣形式儲存資料, 可以用 函式 matrix(). matrix(data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL) 其中引數為 nrow = r 正整數, 設定 列數 (row numbers). ncol = c 正整數, 設定 欄數 或 行數 (column number). byrow = FALSE: 在 {R} 中的自動設定, 矩陣資料是以欄 (行) 位 (column) 優先填滿. 要改變設定, 可改成 byrow = TRUE. dimnames = obj.list 輸入列表設定列位名與欄位名. 使用函式 dim() 可以回傳具有維度數屬性的資料物件之維度大小. ## numeric x.mat &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2) # one row first x.mat ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 dim(x.mat) ## [1] 2 3 y.mat &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2) y.mat ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 z.mat &lt;- matrix(c(1, 2, 3, 4, 5, 6), nrow = 2, byrow = T) z.mat ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 p.mat &lt;- matrix(c(1, 2, 3, 4, 5, 6), ncol = 2, byrow = T) p.mat ## [,1] [,2] ## [1,] 1 2 ## [2,] 3 4 ## [3,] 5 6 w.mat &lt;- matrix(c(1:18), nrow = 3) w.mat ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] 1 4 7 10 13 16 ## [2,] 2 5 8 11 14 17 ## [3,] 3 6 9 12 15 18 dim(y.mat) ## [1] 3 2 # character x.vec &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;) x.vec ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; y.mat &lt;- matrix(x.vec, nrow = 2, ncol = 3) # byrow = F y.mat ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;c&quot; &quot;e&quot; ## [2,] &quot;b&quot; &quot;d&quot; &quot;f&quot; y.mat &lt;- matrix(x.vec, nrow = 2, ncol = 3, byrow = T) y.mat ## [,1] [,2] [,3] ## [1,] &quot;a&quot; &quot;b&quot; &quot;c&quot; ## [2,] &quot;d&quot; &quot;e&quot; &quot;f&quot; dim(y.mat) ## [1] 2 3 # dim m.vec.mat &lt;- 1:10 dim(m.vec.mat) &lt;- c(2, 5) m.vec.mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 dim(m.vec.mat) ## [1] 2 5 3.1.2 矩陣命名 dimnames() 矩陣的命名, 包含欄位名 (column name) 與列位名 (row name), 可以使用函式 dimnames() 分別給予矩陣命名. 可以用函式 dimnames() 同時檢視 matrix 之列位名與欄位名. 若要對讀取或命名矩陣的 列位名 (row name) 或 欄位名 (column name), 也可以用函式指令 rownames() 與 colnames(). # dimnames x.mat &lt;- matrix(1:6, nrow = 2, ncol = 3) dimnames(x.mat) &lt;- list(c(&quot;A1&quot;, &quot;A2&quot;), c(&quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;)) x.mat ## B1 B2 B3 ## A1 1 3 5 ## A2 2 4 6 dim(x.mat) ## [1] 2 3 dimnames(x.mat) ## [[1]] ## [1] &quot;A1&quot; &quot;A2&quot; ## ## [[2]] ## [1] &quot;B1&quot; &quot;B2&quot; &quot;B3&quot; rownames(x.mat) ## [1] &quot;A1&quot; &quot;A2&quot; colnames(x.mat) ## [1] &quot;B1&quot; &quot;B2&quot; &quot;B3&quot; # m.mat &lt;- matrix( c(1, 2, 3, 11, 12, 13), nrow = 2, ncol = 3, byrow = TRUE, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;)) ) m.mat ## C1 C2 C3 ## row1 1 2 3 ## row2 11 12 13 dim(m.mat) ## [1] 2 3 dimnames(m.mat) ## [[1]] ## [1] &quot;row1&quot; &quot;row2&quot; ## ## [[2]] ## [1] &quot;C1&quot; &quot;C2&quot; &quot;C3&quot; rownames(m.mat) ## [1] &quot;row1&quot; &quot;row2&quot; colnames(m.mat) ## [1] &quot;C1&quot; &quot;C2&quot; &quot;C3&quot; 3.2 矩陣的下標與索引 Matrix Index 矩陣的 下標 或 索引 (index) 操作, 如同向量的下標與索引操作, 矩陣具有 \\(2\\)-維度下標向量, 個別下標向量可以輸入正整數, 負數, 整數向量, 欄位名等等. 例如, 可以使用 中括號 matrix.name[i, j] 可存取矩陣中的第 \\([i, j]\\) 元素; matrix.name[i, ] 可存取矩陣中的第 \\(i\\) 列 (\\(i\\)th row), matrix.name[ , j] 可存取矩陣中的第 \\(j\\) 欄 (\\(i\\)th column). 在 {R} 中顯示矩陣物件, [m, ] 出現在某特定元素左方時, 表示某特定元素在該矩陣物件之第 \\(m\\) 列 (row) 的位置; [ , n] 出現在某特定元素上方時, 表示某特定元素在該矩陣物件之第 \\(n\\) 欄 (column) 的位置. ## matrix index x.mat &lt;- matrix(c(1:12), 3, 4) x.mat ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 x.mat[2, 3] &lt;- 30 x.mat ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 30 11 ## [3,] 3 6 9 12 x.mat[2,] ## [1] 2 5 30 11 x.mat[, 3] ## [1] 7 30 9 x.mat[c(1, 3), c(2, 4)] ## [,1] [,2] ## [1,] 4 10 ## [2,] 6 12 # m.mat &lt;- matrix( c(1, 2, 3, 11, 12, 13), nrow = 2, ncol = 3, byrow = TRUE, dimnames = list(c(&quot;row1&quot;, &quot;row2&quot;), c(&quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;)) ) m.mat ## C1 C2 C3 ## row1 1 2 3 ## row2 11 12 13 m.mat[, c(&quot;C1&quot;, &quot;C2&quot;)] ## C1 C2 ## row1 1 2 ## row2 11 12 m.mat[c(&quot;row2&quot;),] ## C1 C2 C3 ## 11 12 13 m.mat[c(&quot;row1&quot;), c(&quot;C1&quot;, &quot;C3&quot;)] ## C1 C3 ## 1 3 矩陣下標與索引若僅選取 1 列 或 1 欄, 則會維度縮減產生向量, 若仍要產生矩陣, 則可加入參數 drop = FALSE. ## dimension reduction x.mat &lt;- matrix(1:8, 2, 4) x.mat[1,] # reduces to a vector ## [1] 1 3 5 7 x.mat[1, , drop = FALSE] # remains as a matrix ## [,1] [,2] [,3] [,4] ## [1,] 1 3 5 7 3.2.1 向量與矩陣的合併: rbind() 與 cbind() 在 {R} 中向量並不具有 沒有維度 (no dimension), 例如, 向量可以視為 \\(1 \\times k\\) 的 向量/矩陣, 也可以視為 \\(k \\times 1\\) 的 向量/矩陣, 但是, 當 向量 與 其它 向量/矩陣 進行運算時, 向量 會受到與其進行運算的矩陣物件影響, {R} 如何處理 向量 與 其它 向量/矩陣 進行運算並沒有清楚的規則, 有時視為 \\(1 \\times k\\) 若任由 {R} 的內在設定, 則將會有意想不到的運算結果, 因此在進行線性代數相關的計算, 若要避免混淆與錯誤, 初學者可將數學的 \\(1\\)-維度 \\(k\\)-個元素的向量, 重新定義成 {R} 的 \\(1 \\times k\\) 的矩陣 或是 \\(k \\times 1\\) 的矩陣, 然後再進行線性代數相關的計算. 同樣, 合併不同 列位數 (row number) 或 欄位數 (column number) 的向量或矩陣, 因為使用 recycle 原則必須小心. ## matrix cbind() and rbind() x.vec &lt;- c(1, 2, 3) y.vec &lt;- c(8, 9, 10) rbind(x.vec, y.vec) # vector as row vector ## [,1] [,2] [,3] ## x.vec 1 2 3 ## y.vec 8 9 10 cbind(x.vec, y.vec) # vector as col vector ## x.vec y.vec ## [1,] 1 8 ## [2,] 2 9 ## [3,] 3 10 # x.mat &lt;- matrix(c(11:16), 2, 3) rbind(x.mat, x.vec) # vector as row vector ## [,1] [,2] [,3] ## 11 13 15 ## 12 14 16 ## x.vec 1 2 3 cbind(x.mat, y.vec) # warning ## Warning in cbind(x.mat, y.vec): number of rows of result is not a multiple of vector ## length (arg 2) ## y.vec ## [1,] 11 13 15 8 ## [2,] 12 14 16 9 # x.vec &lt;- c(1, 2) y.vec &lt;- c(8, 9) rbind(x.vec, y.vec) # vector as row vector ## [,1] [,2] ## x.vec 1 2 ## y.vec 8 9 cbind(x.vec, y.vec) # vector as col vector ## x.vec y.vec ## [1,] 1 8 ## [2,] 2 9 # x.mat &lt;- matrix(c(11:14), 2, 2) z.mat &lt;- rbind(x.mat, x.vec) # vector as row vector z.mat ## [,1] [,2] ## 11 13 ## 12 14 ## x.vec 1 2 cbind(x.mat, y.vec) # vector as col vector ## y.vec ## [1,] 11 13 8 ## [2,] 12 14 9 rbind(z.mat, y.vec) # vector as row vector ## [,1] [,2] ## 11 13 ## 12 14 ## x.vec 1 2 ## y.vec 8 9 cbind(z.mat, y.vec) # warning ## Warning in cbind(z.mat, y.vec): number of rows of result is not a multiple of vector ## length (arg 2) ## y.vec ## 11 13 8 ## 12 14 9 ## x.vec 1 2 8 3.2.2 陣列物件 Array 陣列 (array) 物件也由包含相同模式 (mode) 的元素組成的 \\(p\\)-維資料物件, 也可以將陣列視為一個向量具 \\(p\\)-維結構. 使用函式 array() 產生陣列. {R} 顯示 \\(3\\)-維陣列物件 \\(m \\times n \\times k\\), [m, , ] 出現在某特定元素之前時, 表示某特定元素在該陣列物件之第 \\(m\\) 列 (row) 的位置; [ , n, ] 出現在某特定元素之前時, 表示某特定元素在該陣列物件之第 \\(n\\) 欄 (column) 的位置, 依此類推. [ , , k] 表示 \\(3\\)-維陣列的第 1, 2-維度之矩陣. 陣列的命名, 與矩陣類似, 可以使用函式 dimnames() 分別給予陣列命名. 可以用函式 dimnames() 同時檢視 array 之列位名與欄位名. 陣列的 下標 或 索引 (index) 之操作, 與矩陣下標或索引的操作類似, 使用 中括號 ([i, j, k]). 若要對讀取或命名陣列的第 1 維度 (列位名, row name) {或 第 2 維度 (欄位名, column name**), 也可以用函式指令 rownames() 與 colnames(). ## array() a.vec &lt;- 1:24 a.vec ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 b.array &lt;- array(a.vec, dim = c(4, 3, 2), dimnames = list(c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;, &quot;x4&quot;), c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;), c(&quot;z1&quot;, &quot;z2&quot;))) b.array ## , , z1 ## ## y1 y2 y3 ## x1 1 5 9 ## x2 2 6 10 ## x3 3 7 11 ## x4 4 8 12 ## ## , , z2 ## ## y1 y2 y3 ## x1 13 17 21 ## x2 14 18 22 ## x3 15 19 23 ## x4 16 20 24 mode(b.array) ## [1] &quot;numeric&quot; dim(b.array) ## [1] 4 3 2 length(b.array) ## [1] 24 dimnames(b.array) ## [[1]] ## [1] &quot;x1&quot; &quot;x2&quot; &quot;x3&quot; &quot;x4&quot; ## ## [[2]] ## [1] &quot;y1&quot; &quot;y2&quot; &quot;y3&quot; ## ## [[3]] ## [1] &quot;z1&quot; &quot;z2&quot; rownames(b.array) ## [1] &quot;x1&quot; &quot;x2&quot; &quot;x3&quot; &quot;x4&quot; colnames(b.array) ## [1] &quot;y1&quot; &quot;y2&quot; &quot;y3&quot; # array index a.vec ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 b.array &lt;- array(a.vec, dim = c(4, 3, 2), dimnames = list(c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;, &quot;x4&quot;), c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;), c(&quot;z1&quot;, &quot;z2&quot;))) b.array ## , , z1 ## ## y1 y2 y3 ## x1 1 5 9 ## x2 2 6 10 ## x3 3 7 11 ## x4 4 8 12 ## ## , , z2 ## ## y1 y2 y3 ## x1 13 17 21 ## x2 14 18 22 ## x3 15 19 23 ## x4 16 20 24 b.array[3, 2, 1] ## [1] 7 b.array[4, 3, 2] ## [1] 24 b.array[2, c(1, 3), 1] ## y1 y3 ## 2 10 b.array[3, c(2, 3), 1] ## y2 y3 ## 7 11 b.array[2, ,] ## z1 z2 ## y1 2 14 ## y2 6 18 ## y3 10 22 b.array[, 2,] ## z1 z2 ## x1 5 17 ## x2 6 18 ## x3 7 19 ## x4 8 20 b.array[, , 2] ## y1 y2 y3 ## x1 13 17 21 ## x2 14 18 22 ## x3 15 19 23 ## x4 16 20 24 3.3 列表物件 List 列表 (list) 是一個特殊的 向量, 這特殊的向量中的元素是物件. 列表物件 元素的模式 (mode) 是 複雜模式 (complex mode) 列表物件是由資料物件有順序組成, 列表物中的 ``元素’’, 稱作 成份 (component), 是物件本身, 列表物中的成份是有順序的 (order sequence), 成份物件的元素模式, 沒有任合限制, 每一個別成份的物件之原型模式可以不相同. 列表的產生通常先決定每一個成分的物件, 然後再組合成列表. 3.3.1 列表函式 list() 使用函式 list() 將個別成分組成列表. {R} 許多統計分析的結果常常包含 不同物件, 例如, 迴歸模型分析包含 參數估計, 變異數分析, 預測值與殘差, 每一成分的長度與模式不一, 模型分析產生的結果最後多以列表儲存. ## list() ## list w/o component names x.vec &lt;- 1:4 y.vec &lt;- c(&quot;Male&quot;, &quot;Female&quot;) z.mat &lt;- matrix(1:9, nrow = 3, ncol = 3) xyz.list &lt;- list(x.vec, y.vec, z.mat) xyz.list ## [[1]] ## [1] 1 2 3 4 ## ## [[2]] ## [1] &quot;Male&quot; &quot;Female&quot; ## ## [[3]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 mode(xyz.list) ## [1] &quot;list&quot; length(xyz.list) ## [1] 3 dim(xyz.list) ## NULL names(xyz.list) ## NULL class(xyz.list) ## [1] &quot;list&quot; ## list w/ component names x.num &lt;- c(1, 3, 6) y.str &lt;- c(&quot;chocolate&quot;, &quot;vanilla&quot;, &quot;strawberry&quot;) xy.list &lt;- list(x.num.var = x.num, y.str.var = y.str) xy.list ## $x.num.var ## [1] 1 3 6 ## ## $y.str.var ## [1] &quot;chocolate&quot; &quot;vanilla&quot; &quot;strawberry&quot; # list = data matrix id.vec &lt;- c(1, 2, 3, 4) age.vec &lt;- c(35, 55, 45, 25) sex.vec &lt;- c(&quot;Male&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;) disease.vec &lt;- c(&quot;Yes&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Yes&quot;) x.list &lt;- list( id = id.vec, age = age.vec, sex = sex.vec, disease = disease.vec ) x.list ## $id ## [1] 1 2 3 4 ## ## $age ## [1] 35 55 45 25 ## ## $sex ## [1] &quot;Male&quot; &quot;Male&quot; &quot;Female&quot; &quot;Female&quot; ## ## $disease ## [1] &quot;Yes&quot; &quot;No&quot; &quot;No&quot; &quot;Yes&quot; 3.3.2 列表的下標與索引 List Index 列表物件的 下標 或 索引 之操作, 與矩陣 或 陣列之操作有所不同, 若一個名字為 List.Name 的列表物件, 要取得 list 其中的 第 i.number 成份, 須使用 List.Name[[3]]. 注意, 在列表物件的下標操作, [[i.number]] 與 [i.number] 是不一樣的. ## list index ## list w/o component names x.vec &lt;- 1:4 y.vec &lt;- c(&quot;Male&quot;, &quot;Female&quot;) z.mat &lt;- matrix(1:9, nrow = 3, ncol = 3) xyz.list &lt;- list(x.vec, y.vec, z.mat) xyz.list ## [[1]] ## [1] 1 2 3 4 ## ## [[2]] ## [1] &quot;Male&quot; &quot;Female&quot; ## ## [[3]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 xyz.list[1] ## [[1]] ## [1] 1 2 3 4 xyz.list[[1]] ## [1] 1 2 3 4 xyz.list[2] ## [[1]] ## [1] &quot;Male&quot; &quot;Female&quot; xyz.list[[3]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 xyz.list[3] ## [[1]] ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 若列表中的 成份 (component) 有另外命名為 comp.name, 可以使用函式 List.Name\\$comp.name 取得成份名字, 會與使用函式 List.Name[[comp.name]] 取得相同結果. 在 List.Name\\$comp.name 或 List.Name[[comp.name]] 加上 中括號 等, 可以取得 List.Name\\$comp.name 中的元素. [[i.number]] 可以適用在計算指標, 但 $ 僅能使用在有設定的成分名的列表. 若列表的單一成份內有多維度物件 可使用巢狀下標取出資料. # list w/ component names x.vec &lt;- 1:4 y.vec &lt;- c(&quot;Male&quot;, &quot;Female&quot;) z.mat &lt;- matrix(1:9, nrow = 3, ncol = 3) xyz.list &lt;- list(class = x.vec, gender = y.vec, score = z.mat) xyz.list ## $class ## [1] 1 2 3 4 ## ## $gender ## [1] &quot;Male&quot; &quot;Female&quot; ## ## $score ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 xyz.list$class ## [1] 1 2 3 4 xyz.list[[&quot;class&quot;]] ## [1] 1 2 3 4 xyz.list[[&quot;class&quot;]][2] ## [1] 2 # xyz.list$gender ## [1] &quot;Male&quot; &quot;Female&quot; xyz.list[[&quot;gender&quot;]][1] ## [1] &quot;Male&quot; # xyz.list$score ## [,1] [,2] [,3] ## [1,] 1 4 7 ## [2,] 2 5 8 ## [3,] 3 6 9 xyz.list[[&quot;score&quot;]][2, 3] ## [1] 8 3.4 資料框架 Data Frame 一組資料通常包含數字與文字, 在 {R} 中的向量與矩陣物件, 只允許相同的變數型式, 若要同時存入數字變數與文字變數, {R} 可以使用 列表 (list) 與 函式指令 list(), 列表資料內可包含不同屬性的變數值. 資料框架 (data frame) 是列表物件的一種特殊情境. 在資料框架內的每個變數之觀測值數目 (向量長度) 都相等, 類似矩陣型式, 但是每個變數的變數值不一定是相同的模式, 因此資料框架對統計人員而言, 常稱為 資料矩陣 (data matrix), 是一般統計資料分析常用的形式. 注意: {R} 資料框架物件操作類似 {R} 矩陣物件, 但 {R} 資料框架物件本質上為 {R} 列表物件. 3.5 資料框架函式 data.frame() {R} 可以使用函式 data.frame() 將資料儲存成 資料框架物件. 輸入時須注意每個變數之觀測值數目 (向量長度) 都必須相等, 若有缺失值, 須先將缺失值符號輸入在向量內. ## data frame id.vec &lt;- c(1, 2, 3, 4) age.vec &lt;- c(35, 55, 45, 25) sex.vec &lt;- c(&quot;Male&quot;, &quot;Male&quot;, &quot;Female&quot;, &quot;Female&quot;) disease.vec &lt;- c(&quot;Yes&quot;, &quot;No&quot;, &quot;No&quot;, &quot;Yes&quot;) x.df &lt;- data.frame( id = id.vec, age = age.vec, sex = sex.vec, disease = disease.vec ) mode(x.df) ## [1] &quot;list&quot; class(x.df) ## [1] &quot;data.frame&quot; x.df ## id age sex disease ## 1 1 35 Male Yes ## 2 2 55 Male No ## 3 3 45 Female No ## 4 4 25 Female Yes x.df$age ## [1] 35 55 45 25 x.df$disease ## [1] &quot;Yes&quot; &quot;No&quot; &quot;No&quot; &quot;Yes&quot; 3.5.1 資料框架的下標與索引 Data Frame Index 資料框架的 下標 或 索引 (index) 操作, 如同矩陣的下標與索引操作, 可以輸入正整數, 負數, 整數向量, 欄位名等等. 矩陣具有 \\(2\\)-維度下標向量, 例如, 可以使用 中括號 dataframe.name[i, j] 可存取資料框中的第 \\([i, j]\\) 元素; dataframe.name[i, ] 可存取資料框中的第 \\(i\\) 列 (\\(i\\)th row), dataframe.name[ , j] 可存取資料框中的第 \\(j\\) 欄 (\\(i\\)th column). 資料框架是列表的特例, 因此資料框架的 下標 或 索引 (index) 操作, 也可如同列表的下標與索引操作. 若一個名為 data.Name 的資料框架, 要取的其中的 第 `i.number'' 變數 (成份), 須使用data.Name[[3]]. 注意, 在資料框架物件的下標操作,[[i.number]]與[i.number]是不一樣的. 若資料框架中的變數命名為variable.name, 可以使用函式dataframe.Name$variable.name取得變數資料, 會與使用函式dataframe.Name[[variable.name]] 取得相同結果. 在 dataframe.Name\\$variable.name 或 dataframe.Name[[variable.name]] 加上 中括號 [i] 等, 可以取得 dataframe.Name\\$variable.name 中的元素. [[i.number]] 可以適用在計算指標, 但 $ 僅能使用在有設定變數名的資料框架. ## data frame index data(Puromycin) Puromycin ## conc rate state ## 1 0.02 76 treated ## 2 0.02 47 treated ## 3 0.06 97 treated ## 4 0.06 107 treated ## 5 0.11 123 treated ## 6 0.11 139 treated ## 7 0.22 159 treated ## 8 0.22 152 treated ## 9 0.56 191 treated ## 10 0.56 201 treated ## 11 1.10 207 treated ## 12 1.10 200 treated ## 13 0.02 67 untreated ## 14 0.02 51 untreated ## 15 0.06 84 untreated ## 16 0.06 86 untreated ## 17 0.11 98 untreated ## 18 0.11 115 untreated ## 19 0.22 131 untreated ## 20 0.22 124 untreated ## 21 0.56 144 untreated ## 22 0.56 158 untreated ## 23 1.10 160 untreated Puromycin$rate ## [1] 76 47 97 107 123 139 159 152 191 201 207 200 67 51 84 86 98 115 131 124 ## [21] 144 158 160 Puromycin$state ## [1] treated treated treated treated treated treated treated treated ## [9] treated treated treated treated untreated untreated untreated untreated ## [17] untreated untreated untreated untreated untreated untreated untreated ## Levels: treated untreated Puromycin[1] ## conc ## 1 0.02 ## 2 0.02 ## 3 0.06 ## 4 0.06 ## 5 0.11 ## 6 0.11 ## 7 0.22 ## 8 0.22 ## 9 0.56 ## 10 0.56 ## 11 1.10 ## 12 1.10 ## 13 0.02 ## 14 0.02 ## 15 0.06 ## 16 0.06 ## 17 0.11 ## 18 0.11 ## 19 0.22 ## 20 0.22 ## 21 0.56 ## 22 0.56 ## 23 1.10 Puromycin[1][[1]] ## [1] 0.02 0.02 0.06 0.06 0.11 0.11 0.22 0.22 0.56 0.56 1.10 1.10 0.02 0.02 0.06 0.06 ## [17] 0.11 0.11 0.22 0.22 0.56 0.56 1.10 Puromycin$state[1:3] ## [1] treated treated treated ## Levels: treated untreated Puromycin[1:3, 1:2] ## conc rate ## 1 0.02 76 ## 2 0.02 47 ## 3 0.06 97 "],
["資料輸入與輸出.html", "Chapter 4 資料輸入與輸出 4.1 資料框架 4.2 輸入外部 ASCII 資料檔案至 R 資料框架: 空白分隔 4.3 輸入外部 ASCII 資料檔案至 R 資料框架: 逗號分隔 4.4 R 內建資料框架 4.5 輸出 {R} 資料 4.6 儲存 {R} 格式資料檔", " Chapter 4 資料輸入與輸出 在 {R} 中, 資料以具有名稱的 物件 形式儲存, 它們可以是向量 (vector), 矩陣 (matrix), 陣列 (array), 列表 (Lists), 或 資料框架 (data frames) 等. 簡單的資料, 可以直接在 {R} 視窗中輸入, 大型資料, 通常先以資料庫軟體, 試算表軟體等輸入儲存成外部檔案, 由 {R} 從外部檔案中讀入, 而不是直接在 {R} 中使用鍵盤輸入. {R} 可以讀入純文字 ASCII 格式的資料檔, {R} 也有許多套件可以讀入許多不同格式檔案與資料庫關聯檔案, SAS, SPSS, STATA, EXCEL, 網路公開資料, web open data (XML, HTML JSON), image, texts, stock market, social media 等. 每一資料的儲存格式不盡相同, 通常由儲存資料的軟體所決定, 通常可由檔案的附檔名得知資料的儲存格式. {R} 對輸入資料的原先設計, 假設使用者利用其他工具, 如文書檔編輯器, 資料庫軟體, 或試算表軟體等, 輸入原始資料並儲存成 {R} 的外部原始資料檔案, 任何外部原始資料檔案, 必須修改成特定的 {R} 輸入檔格式, 以使它們符合 {R} 輸入外部原始資料檔案的要求, 對統計分析來說, 這是比較容易地進行外部原始資料的管理. 如同多數專業統計軟體, 不是專業的資料庫軟體, 外部原始資料的管理, 通常都是藉由專業的資料庫軟體進行. 任何資料庫軟體都可以將資料輸出純文字 ASCII 格式的資料檔案, 且任何資料庫軟體或文書檔編輯器都可讀入純文字 ASCII 格式的資料檔案. 4.1 資料框架 統計計算可以進行分析的資料, 通常有一個的簡單的基本架構, 在 {R} 稱作 資料框架 (data frame). 資料框架是類似於在 SAS, STATA 等的 dataset 架構. 資料框架通常類似矩陣, 資料框架也類似矩形的 交叉列聯表 (cross table). 在 {R} 中, 資料框架是統計分析中最基本的資料結構, 許多統計模型分析都必須用到資料框架結構, 資料框架與矩陣類似, 不同的地方在資料框架變數不需要是相同的變數形式或種類, 實數變數, 整數變數, 文字類別變數, 邏輯變數等都可放在同一資料框架中, 資料框架的基本架構如下表. 但是矩陣物件只能有相同的變數 模式 (mode) 的元素組成. 原始資料檔案 DMTKRtabsep.txt 與 DMTKRblanksep.txt: 以純文字空白分隔儲存 No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS INFECT 1 67 0 0 10 120 160 140 180 0 0 56 92 1 0 2 67 0 0 11 100 150 150 220 0 1 62 62 0 1 3 72 1 0 4 150 200 120 150 2 0 60 94 1 0 4 82 1 0 8 150 200 160 250 0 1 47 90 1 0 5 73 1 0 3 85 110 140 200 0 0 44 88 0 0 資料框架有一些特徵, 舉例如下. 第 1 列 (橫列, row), 可以是變數的 變數名 (variable names) 第 1 列 (row), 有時是變數的 欄位標籤 (column label), 而第 2 列 (row) 為變數名. 每個變數各自形成 1 欄 (縱行, row). 第 1 欄 (縱行, column) 為個體辨識碼 (label, identification), 或稱 列位標籤 (row label). 每一欄 (變數) 的變數值形式可以是實數, 文字, 邏輯變數. 第一欄 (column) 有時候是 列位標籤 (row label). 變數名稱以英文為起始, 之後可包含文字與數字, 不可使用標點符號與空格, 有些軟體可以使用 underscore _. 變數值通常為數字, 整數或文字, 儘量避免直接輸入文字, 因為大小寫, 符號, 空格的輸入經常造成錯誤. 變數值通常為數字, 整數, 邏輯值或文字, 儘量避免直接輸入文字, 因為大小寫, 符號, 空格的輸入經常造成錯誤. 若原始資料沒有 變數名 或 標籤, {R} 讀入資料時可以同時輸入變數名, 或讀入資料後, 再輸入變數名. 4.2 輸入外部 ASCII 資料檔案至 R 資料框架: 空白分隔 任何資料庫軟體都可以將資料輸出純文字 ASCII 格式的資料檔案, 且任何資料庫軟體或文書檔編輯器都可讀入純文字 ASCII 格式的資料檔案. 統計分析通常需要讀取外部 原始資料 (raw data) 檔案, {R} 對輸入資料的原先設計時讀入純文字 ASCII 格式的資料檔案, 暫存到電腦的記憶體上, 形成 {R} 資料框架, 對初學者而言讀入或輸出外部純文字 ASCII 格式的資料檔案最為容易. {R} 統計分析主要在資料框架 (data frame) 中的變數進行分析操作, {R} 使用資料框架函式指令 read.table() 或 read.csv() 讀入外部資料檔案, 對初學者而言最為容易. 而其他函式, 例如, scan() 讀取外部資料, 對初學者而言較困難. 為了可以直接讀取整個外部檔案進入 {R} 並形成 {R} 的資料框架物件, 純文字 ASCII 格式的外部檔案常常要求有特定的格式, 例如: 多數檔編輯器, 資料庫, 試算表等軟體可以存取. 第一的列 (the first row) 可以有該資料各個變數的 變數名 (variable names) 或是 行位名, 欄位名 (column name) 或是 欄位標籤 (column label). 第一欄 (the first column) 有時候是 列的標籤 (row label) 或是 列的名字 (row name). 其餘的列 (row), 是個別變數的觀測數值. 變數值之間常以 空白鍵 () (blank space) 分開, 也可以其他特定符號 ’Tab` 分隔. 若是變數資料是文字列型, 通常以雙引號包含, 但有時例外, 需視資料原始儲存軟體的設定. 純文字 ASCII 格式, 變數值以空格分開的副檔名通常為 .dat, .prn 或 .txt. 若變數之間以 , (逗號) 分開變數值的 ASCII 形式檔案, 一般稱為 comma-separated-variable format 或 CSV format, 檔案名通常以 .csv 作為延伸檔名. 初學者的原始資料之變數名稱 (variable name) 不要使用 中文, 空格, 盡量少用 . (點, dot), 或 _ (underscore). 中文, 以免容易造成錯誤. 初學者盡量不要使用 文字 作為變數值 (observed value). 變數值之間以空白鍵或 特定符號 Tab 鍵分開意義不同, 不同軟體讀入這 2 種 ASCII 資料有所不同. 這很難區分, 初學者盡量使用 CSV format. # DMTKRblanksep.txt = &quot; &quot; single space separate Rblanksep.df = read.table(&quot;C:/RData/DMTKRblanksep.txt&quot;, header = TRUE, row.names = NULL, dec = &quot;.&quot;) head(Rblanksep.df) ## No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS INFECT ## 1 1 67 0 0 10 120 160 140 180 0 0 56 92 1 0 ## 2 2 67 0 0 11 100 150 150 220 0 1 62 62 0 1 ## 3 3 72 1 0 4 150 200 120 150 2 0 60 94 1 0 ## 4 4 82 1 0 8 150 200 160 250 0 1 47 90 1 0 ## 5 5 73 1 0 3 85 110 140 200 0 0 44 88 0 0 ## 6 6 76 0 0 1 120 150 120 200 0 1 52 94 1 0 str(Rblanksep.df) ## &#39;data.frame&#39;: 78 obs. of 15 variables: ## $ No : int 1 2 3 4 5 6 7 8 9 10 ... ## $ age : int 67 67 72 82 73 76 76 77 64 64 ... ## $ sex : int 0 0 1 1 1 0 0 0 0 0 ... ## $ DM : int 0 0 0 0 0 0 0 1 0 0 ... ## $ DMyr : int 10 11 4 8 3 1 1 35 5 5 ... ## $ preAC : int 120 100 150 150 85 120 120 200 130 130 ... ## $ prePC : int 160 150 200 200 110 150 150 250 180 180 ... ## $ postAC: int 140 150 120 160 140 120 120 230 100 100 ... ## $ postPC: int 180 220 150 250 200 200 200 300 150 150 ... ## $ Med : int 0 0 2 0 0 0 0 1 0 0 ... ## $ SIDE : int 0 1 0 1 0 1 0 1 0 1 ... ## $ PREKS : int 56 62 60 47 44 52 48 42 40 45 ... ## $ POSKS : int 92 62 94 90 88 94 96 90 94 96 ... ## $ ABS : int 1 0 1 1 0 1 0 1 1 0 ... ## $ INFECT: int 0 1 0 0 0 0 0 0 0 0 ... ## complete read.table ## DMTKRblanksep.txt = &quot; &quot; single space separate Rblanksep.df = read.table(&quot;C:/RData/DMTKRblanksep.txt&quot;, header = TRUE, sep = &quot; &quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, row.names = NULL, # col.names, as.is = TRUE, # as.is = !stringsAsFactors, na.strings = c(&quot;.&quot;, &quot;NA&quot;)) head(Rblanksep.df) ## No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS INFECT ## 1 1 67 0 0 10 120 160 140 180 0 0 56 92 1 0 ## 2 2 67 0 0 11 100 150 150 220 0 1 62 62 0 1 ## 3 3 72 1 0 4 150 200 120 150 2 0 60 94 1 0 ## 4 4 82 1 0 8 150 200 160 250 0 1 47 90 1 0 ## 5 5 73 1 0 3 85 110 140 200 0 0 44 88 0 0 ## 6 6 76 0 0 1 120 150 120 200 0 1 52 94 1 0 str(Rblanksep.df) ## &#39;data.frame&#39;: 78 obs. of 15 variables: ## $ No : int 1 2 3 4 5 6 7 8 9 10 ... ## $ age : int 67 67 72 82 73 76 76 77 64 64 ... ## $ sex : int 0 0 1 1 1 0 0 0 0 0 ... ## $ DM : int 0 0 0 0 0 0 0 1 0 0 ... ## $ DMyr : int 10 11 4 8 3 1 1 35 5 5 ... ## $ preAC : int 120 100 150 150 85 120 120 200 130 130 ... ## $ prePC : int 160 150 200 200 110 150 150 250 180 180 ... ## $ postAC: int 140 150 120 160 140 120 120 230 100 100 ... ## $ postPC: int 180 220 150 250 200 200 200 300 150 150 ... ## $ Med : int 0 0 2 0 0 0 0 1 0 0 ... ## $ SIDE : int 0 1 0 1 0 1 0 1 0 1 ... ## $ PREKS : int 56 62 60 47 44 52 48 42 40 45 ... ## $ POSKS : int 92 62 94 90 88 94 96 90 94 96 ... ## $ ABS : int 1 0 1 1 0 1 0 1 1 0 ... ## $ INFECT: int 0 1 0 0 0 0 0 0 0 0 ... 4.3 輸入外部 ASCII 資料檔案至 R 資料框架: 逗號分隔 另一種原始資料以純文字 ASCII 格式檔儲存, 且變數值之間是以 逗號 , (comma) 分隔的 ASCII 檔案, 其格式化稱為 csv format (comma-separated-variable format), 副檔名通常為 .csv. 使用函式 read.table() 自動內設以空格分開變數值, 必須更改分開變數值符號為 ,. 使用函式 read.csv() 自動內設以 , 分開變數值. ## read data file: DMTKRcsv.csv read_table.df &lt;- read.table(&quot;C:/RData/DMTKRcsv.csv&quot;, header = TRUE, row.names = NULL, sep = &quot;,&quot;, dec = &quot;.&quot;) head(read_table.df, n = 3) ## No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS INFECT ## 1 1 67 0 0 10 120 160 140 180 0 0 56 92 1 0 ## 2 2 67 0 0 11 100 150 150 220 0 1 62 62 0 1 ## 3 3 72 1 0 4 150 200 120 150 2 0 60 94 1 0 # simple one read_csv.df &lt;- read.csv(&quot;C:/RData/DMTKRcsv.csv&quot;) head(read_csv.df, n = 3) ## No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS INFECT ## 1 1 67 0 0 10 120 160 140 180 0 0 56 92 1 0 ## 2 2 67 0 0 11 100 150 150 220 0 1 62 62 0 1 ## 3 3 72 1 0 4 150 200 120 150 2 0 60 94 1 0 # read_csv.df &lt;- read.csv(&quot;C:/RData/DMTKRcsv.csv&quot;, header = TRUE, row.names = NULL, sep = &quot;,&quot;, dec = &quot;.&quot;) head(read_csv.df, n = 3) ## No age sex DM DMyr preAC prePC postAC postPC Med SIDE PREKS POSKS ABS INFECT ## 1 1 67 0 0 10 120 160 140 180 0 0 56 92 1 0 ## 2 2 67 0 0 11 100 150 150 220 0 1 62 62 0 1 ## 3 3 72 1 0 4 150 200 120 150 2 0 60 94 1 0 4.4 R 內建資料框架 {R} 有許多內建資料框架, 另外貢獻套件 (contributed packages) 也有許多內建的資料框架, 可以使用 data() 查看 {R} 內建資料框架名稱, 或使用 library(help = \"datasets\") 查看 {R} 內建資料框架名稱. 使用 data(package = \"package.name\") 查看名稱為 package.name 套件中的資料框架名稱, 載入資料框架, 可用 data(data.name) 載入 {R} 內建名稱為 data.name 資料框架使用, 或 data(package.data.name, package = \"package.name\") 載入名稱為 package.name 套件中, 名稱為 pack.data.name 資料框架使用. # data() # check names of datasets data(Orange) # use {R} build-in dataset = Orange # help(Orange) head(Orange) ## Tree age circumference ## 1 1 118 30 ## 2 1 484 58 ## 3 1 664 87 ## 4 1 1004 115 ## 5 1 1231 120 ## 6 1 1372 142 # library(MASS) # help(package = MASS) # data(package = &quot;MASS&quot;) # check MASS package data set data(VA, package = &quot;MASS&quot;) # use MASS package dataset = VA # help(VA) head(VA) ## stime status treat age Karn diag.time cell prior ## 1 72 1 1 69 60 7 1 0 ## 2 411 1 1 64 70 5 1 10 ## 3 228 1 1 38 60 3 1 0 ## 4 126 1 1 63 60 9 1 10 ## 5 118 1 1 65 70 11 1 10 ## 6 10 1 1 49 20 5 1 0 4.5 輸出 {R} 資料 由 {R} 程式產生的資料, 可以儲存成外部資料檔案. 包含函式 write.table() 與 write.csv(). 其引數如下. x = 匯出的 {R} 物件名 file = 路徑與檔案名稱 append = FALSE 預設不在檔案末端附加資料 quote = \"\\\"\" 預設文字變數值使用雙引號將 sep = \" \" 預設空白分隔符號 eol = \"\\n\" 設定換行符號 na = NA 設定 NA 符號 dec = '.' 設定小數點符號 row.names = TRUE 設定輸出 row names col.names = TRUE 設定輸出變數名 (column names) qmethod = c(\"escape\", \"double\") 文字變數值有當引號時的分隔符號 fileEncoding = \"\" 設定檔案編碼 使用函式 write.csv() 儲存檔案與函式 write.table() 類似, 但使用 sep = \",\". 4.6 儲存 {R} 格式資料檔 函式 saveRDS() 可將資料儲存成 {R} 格式的外部資料檔案. 函式 readRDS() 可將外部 {R} 格式資料輸入. 主要是在用在大數據檔案, 若每次輸入外部資料檔案非常費時, 可以將已經轉成 data frame 物件的資料直接儲存成 {R} 格式的外部資料檔案. 只要使用函式 readRDS() 輸入, 可以節省許多時間. {R} 另外一組函式 save() 與函式 load() 有類似功能, 較較不方便. ## saveRDS() and save() x &lt;- c(1:5) saveRDS(x, file = &quot;C:/RData/x.Rds&quot;) save(x, file = &quot;C:/RData/x.Rda&quot;) # working directory ## readRDS() new_x &lt;- readRDS(file = &quot;C:/RData/x.Rds&quot;) new_x ## [1] 1 2 3 4 5 ## load() -- note the result new_x &lt;- load(file = &quot;C:/RData/x.Rda&quot;) new_x ## [1] &quot;x&quot; x ## [1] 1 2 3 4 5 "],
["資料視覺化分析.html", "Chapter 5 資料視覺化分析 5.1 視覺化分析原則 5.2 繪圖套件 ggplot2 5.3 類別變數 5.4 連續變數 5.5 混合變數 5.6 分組繪圖", " Chapter 5 資料視覺化分析 繪圖文法是讓一個圖形容易思考, 合理討論與溝通的抽像規則. \\ Leland Wilkinson (1999), The Grammar of Graphics. {R} 內建許多繪圖工具函式, 這些繪圖工具可以顯示各種統計繪圖並且自建一些全新的圖. {R} 繪圖工具函式之特色是用同一個繪圖函式, 對不同類型的物件, 可以作出不同的圖形. 繪圖工具函式既可互動式使用, 也可以批次處理使用. 在許多情況下, 使用互動式 (interactive) 執行 {R} 的圖形繪製, 是一個相當有效的方式. {R} 基本繪圖工具包含 高階繪圖函式 與 低階繪圖函式, 或是合併二種方式形成互動式繪圖函式: 高階繪圖函式 (high-levlel plotting functions): 直接形成完整圖形, 圖形包括坐標軸, 標籤, 標題等等. 低階繪圖函式 (low-level plotting functions): 是將 點, 線, 座標與標籤等逐步形成圖形. 繪圖工具函式所產生之圖形結果, 無法指定成物件, 必須送到 圖形裝置 graphic device), 圖形裝置可以是一個視窗或某一特定格式之圖形檔案, {R} 可以將圖形儲存在各種圖形裝置, 包含 pdf, ps, jpg, png 檔案等等. 在 {R} 中還有有一個獨立的強大之繪圖系統, grid 套件, 類似 Splus 裏的 Trellis 繪圖系統. 根據 grid 套件, 所建構的另一個較容易使用之 lattice, ggplot2 等. 可以產生多重漂亮起專業的統計繪圖. 目前主流使用 tidyverse 套件系統 包含許多不同套件, 提供資料科學一些實用的函式, 其中 ggplot2 為視覺化分析套件. 以套件 ggplot2 為基礎, 已經衍生出許多其他繪圖套件. 5.1 視覺化分析原則 Edward Tufte (2006) 在 Beautiful Evidence 書中提出一些視覺化分析原則. 顯示比較. 顯示因果關係或關聯性. 顯示多變量資料. 整合不同資料的證據. 描述與紀錄證據. 顯示實質內容最重要. 5.2 繪圖套件 ggplot2 繪圖套件 ggplot2 是一個龐大的繪圖系統, 開始學習 ggplot2 的程式語言會有些困難, 但中等程度複雜的圖形, 使用 ggplot2 通常會比使用 R base 繪圖系統容易. 統計繪圖學習方式可從已經發表且有程式碼的圖形學起, 例如, https://www.r-graph-gallery.com/index.html. ggplot2 的概念是使用結構性的語法, 先指定資料, 然後指定變數, 再指定幾何元素, 最後處裡標題與標注數據以及背景的主題式樣. 必要時考慮分組呈現相同圖形. ggplot2 的概念如同繪畫, 可隨時 使用 + 加上圖層 (layers), 更新或取代原有圖層. data: 選取資料. mapping (aes): 選取資料內變數進行對應或映射 x-變數, y-變數, treat, fill, shape, size, etc. geoms: 幾何物件 geometric object point, line, bar, shapes, ribbon, polygon, smooth, text etc. stat: 計算統計量/變數轉換, statistics position: 調整位置 position adjustments. Table: ggplot2 指令與引數 函式 ggplot() 基本程式如下. ggplot(data = data_name, aes(x = variable_name, y = variable_name, ... &lt;other variable_name mappings&gt;)) + geom_&lt;type}() + ... Prentice (1973) 報告一個研究, 關於年長退伍軍人罹患肺癌, 且無法接受手術之臨床試驗, %病患在 Veteran’s Administration 醫院隨機接受標準治療或新的化學療法, 病患在榮民醫院隨機接受標準治療方法或新的化學治療方法, 比較治療的主要結果變數為死亡時間, 變數名稱列在表. 資料在檔案 survVATrial.csv. 變數 描述 treat (therapy) 治療組別: 0 = 標準; 1 = 新治療 cellcode 細胞型態; 1 = 鱗狀細胞; 2 = 小細胞; 3 = 腺體細胞; 4 = 大細胞 time 存活時間, 診斷日期至死亡日期, 單位以日計 censor 設限狀態: 0 = 設限; 1 = 死亡 diagtime Karnofsky performance score, 診斷時身體狀態表現的分數 diagtime 診斷到隨機分配的時間, 以月計 age 診斷時的年齡 (以年計) prior 先前是否接受治療; 0 = 無; 1 = 有 dd &lt;- read.table(&quot;./Data/survVATrial.csv&quot;, header = TRUE, sep = &quot;,&quot;, quote = &quot;\\&quot;&#39;&quot;, dec = &quot;.&quot;, row.names = NULL, # col.names, as.is = TRUE, # as.is = !stringsAsFactors, na.strings = c(&quot;.&quot;, &quot;NA&quot;)) head(dd) ## treat cellcode time censor diagtime kps age prior ## 1 0 1 72 1 60 7 69 0 ## 2 0 1 411 1 70 5 64 10 ## 3 0 1 228 1 60 3 38 0 ## 4 0 1 126 1 60 9 63 10 ## 5 0 1 118 1 70 11 65 10 ## 6 0 1 10 1 20 5 49 0 str(dd) ## &#39;data.frame&#39;: 137 obs. of 8 variables: ## $ treat : int 0 0 0 0 0 0 0 0 0 0 ... ## $ cellcode: int 1 1 1 1 1 1 1 1 1 1 ... ## $ time : int 72 411 228 126 118 10 82 110 314 100 ... ## $ censor : int 1 1 1 1 1 1 1 1 1 0 ... ## $ diagtime: int 60 70 60 60 70 20 40 80 50 70 ... ## $ kps : int 7 5 3 9 11 5 10 29 18 6 ... ## $ age : int 69 64 38 63 65 49 69 68 43 70 ... ## $ prior : int 0 10 0 10 10 0 10 0 0 0 ... dd$treat &lt;- factor(dd$treat, labels = c(&quot;placebo&quot;, &quot;test&quot;)) dd$cellcode &lt;- factor(dd$cellcode, labels = c(&quot;squamous&quot;, &quot;small&quot;, &quot;adeno&quot;, &quot;large&quot;)) dd$censor &lt;- factor(dd$censor, labels = c(&quot;survival&quot;, &quot;dead&quot;)) dd$prior &lt;- factor(dd$prior, labels = c(&quot;no&quot;, &quot;yes&quot;)) head(dd) ## treat cellcode time censor diagtime kps age prior ## 1 placebo squamous 72 dead 60 7 69 no ## 2 placebo squamous 411 dead 70 5 64 yes ## 3 placebo squamous 228 dead 60 3 38 no ## 4 placebo squamous 126 dead 60 9 63 yes ## 5 placebo squamous 118 dead 70 11 65 yes ## 6 placebo squamous 10 dead 20 5 49 no str(dd) ## &#39;data.frame&#39;: 137 obs. of 8 variables: ## $ treat : Factor w/ 2 levels &quot;placebo&quot;,&quot;test&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ cellcode: Factor w/ 4 levels &quot;squamous&quot;,&quot;small&quot;,..: 1 1 1 1 1 1 1 1 1 1 ... ## $ time : int 72 411 228 126 118 10 82 110 314 100 ... ## $ censor : Factor w/ 2 levels &quot;survival&quot;,&quot;dead&quot;: 2 2 2 2 2 2 2 2 2 1 ... ## $ diagtime: int 60 70 60 60 70 20 40 80 50 70 ... ## $ kps : int 7 5 3 9 11 5 10 29 18 6 ... ## $ age : int 69 64 38 63 65 49 69 68 43 70 ... ## $ prior : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 1 2 1 2 2 1 2 1 1 1 ... 5.3 類別變數 類別變數描述性統計主要是分析變數的 分配 或 分佈 (distribution), 分配敘述變數的觀測數值以及這些觀測數值出現的頻率. 類別變數描述性統計圖表常見為 頻率表 (frequency table), 長條圖 (bar plot) 與圓形圖 (pie chart). 對統計人員而言, 類別變數使用圓形圖呈現. 是非常不好的資料呈現方式, 使用頻率表 (Table) 或長條圖較佳. 5.3.1 單類別變數 單類別變數: 檢視類別水準的頻率大小. ## pie chart: ggplot2 do not have a simple geom_pie() ## use R base pie() cellcode.tab &lt;- table(dd$cellcode) cellcode.tab ## ## squamous small adeno large ## 35 48 27 27 prop.table(cellcode.tab) ## ## squamous small adeno large ## 0.2554745 0.3503650 0.1970803 0.1970803 barplot(cellcode.tab) round(barplot(cellcode.tab), 4) ## [,1] ## [1,] 0.7 ## [2,] 1.9 ## [3,] 3.1 ## [4,] 4.3 pie(cellcode.tab) library(ggplot2) ## bar chart ggplot(data = dd, aes(x = cellcode)) + geom_bar(treat = &quot;blue&quot;) ## Warning: Ignoring unknown parameters: treat ggplot(data = dd, aes(x = cellcode)) + geom_bar(treat = &quot;blue&quot;) + coord_flip() ## Warning: Ignoring unknown parameters: treat ggplot(data = dd, aes(y = cellcode)) + geom_bar(treat = &quot;blue&quot;) ## Warning: Ignoring unknown parameters: treat # pie chart: no simple solution clar.freq &lt;- data.frame(cellcode.tab) names(clar.freq)[1] &lt;- &quot;cellcode&quot; clar.freq ## cellcode Freq ## 1 squamous 35 ## 2 small 48 ## 3 adeno 27 ## 4 large 27 ggplot(data = clar.freq, aes(x = &quot;&quot;, y = Freq, fill = cellcode)) + geom_bar(width = 1, stat = &quot;identity&quot;) + coord_polar(&quot;y&quot;, start = 0) ggplot(data = clar.freq, aes(x = &quot;&quot;, y = Freq, fill = cellcode)) + geom_bar(stat = &quot;identity&quot;, width = 1, treat = &quot;white&quot;) + coord_polar(theta = &quot;y&quot;, start = 0) + theme_void() # remove background ## Warning: Ignoring unknown parameters: treat 5.3.2 多類別變數 雙類別變數: 檢視變數聯合水準的頻率大小, 檢視條件水準的頻率大小. ## two categorical vtriables table(dd$treat) ## ## placebo test ## 69 68 table(dd$cellcode) ## ## squamous small adeno large ## 35 48 27 27 twoway.tab &lt;- table(dd$treat, dd$cellcode) twoway.tab ## ## squamous small adeno large ## placebo 15 30 9 15 ## test 20 18 18 12 ## # cell proportion cell.prop &lt;- prop.table(twoway.tab, margin=NULL) round(cell.prop, 3) ## ## squamous small adeno large ## placebo 0.109 0.219 0.066 0.109 ## test 0.146 0.131 0.131 0.088 ## conditional on row sum to 1 cond_row_prop &lt;- prop.table(twoway.tab, margin = 1) round(cond_row_prop, 3) ## ## squamous small adeno large ## placebo 0.217 0.435 0.130 0.217 ## test 0.294 0.265 0.265 0.176 apply(cond_row_prop, 1, sum) # rows sum to 1 ## placebo test ## 1 1 ## conditional on column sum to 1 cond_col_prop &lt;- prop.table(twoway.tab, margin = 2) round(cond_col_prop, 3) ## ## squamous small adeno large ## placebo 0.429 0.625 0.333 0.556 ## test 0.571 0.375 0.667 0.444 apply(cond_col_prop, 2, sum) # cols sum to 1 ## squamous small adeno large ## 1 1 1 1 ## side-by-side bar plot barplot(twoway.tab, beside = TRUE, main = &quot;treat By cellcode&quot;, xlab = &quot;clarty&quot;) # Stacked Bar Plot barplot(twoway.tab, beside = FALSE, main = &quot;treat By cellcode&quot;, xlab = &quot;treat&quot;) ## ggplot2 ## Automatically stack library(ggplot2) ggplot(data = dd, aes(x = cellcode, fill = treat)) + geom_bar() ggplot(data = dd, aes(x = cellcode, fill = treat)) + geom_bar(position = &quot;stack&quot;) ## side-by-side ggplot(data = dd, aes(x = cellcode, fill = treat)) + geom_bar(position = &quot;dodge&quot;) ggplot(data = dd, aes(x = cellcode, fill = treat)) + geom_bar(position = &quot;fill&quot;) 5.4 連續變數 連續變數描述性統計主要是分析變數的 分配 或 分佈 (distribution), 分配敘述變數的觀測數值以及這些觀測數值出現的頻率. 連續變數描述性統計圖表常見為 點狀圖 (dot plot), 枝葉圖 (stem-and-leaf), 次數分配表, 直方圖 (histogram), 盒鬚圖 (box plot), 密度圖 (density plot), 平均值, 變異數等. 對連續變數的描述, 若樣本數較少, 常使用點狀圖或枝葉圖. 目前多數為大數據, 點狀圖或枝葉圖較少使用, 但在實驗設計的數據呈現仍然非常重要. 5.4.1 單連續變數 單連續變數: 檢視中央趨勢, 離散程度 偏度, 峰度. ## use R base pie() ## histogram hist(dd$time, freq = TRUE, main = &quot;time histogram&quot;, xlab = &quot;time&quot;) hist(dd$time, freq = FALSE, main = &quot;time histogram&quot;, xlab = &quot;time&quot;) # box plot boxplot(dd$time, xlab = &quot;time&quot;) # QQ plot qqnorm(dd$time, main = &quot;Normal QQ Plot: time&quot;) # density plot plot(density(dd$time), pch = 16, main = &quot;Density Plot&quot;, xlab = &quot;time&quot;, ylab = &quot;density&quot;) ## ggplot2 ## histogram ggplot(data = dd, aes(x = time)) + geom_histogram() ## box plot ggplot(dd, aes(x = &quot;&quot;, y = time)) + geom_boxplot() ## violin plot ggplot(dd, aes(x = &quot;&quot;, y = time)) + geom_violin() ## density plot ggplot(data = dd, aes(x = time)) + geom_freqpoly() ggplot(data = dd, aes(x = time)) + stat_bin(geom = &quot;area&quot;) ggplot(data = dd, aes(x = time)) + stat_bin(geom = &quot;line&quot;) 5.4.2 二連續變數 散佈圖 scatter plot = X &amp; Y = 連續變數 雙連續變數: 檢視二個變數關聯性, 大小, 方向, 趨勢. ## R base ## scatter plot ## basic plot(x = dd$diagtime, y = dd$time) ## formulat y ~ x, data = data_name) plot(time ~ diagtime, data = dd) ## ggplot ggplot(data = dd, aes(x = diagtime, y = time)) + geom_point() ggplot(data = dd, aes(x = diagtime, y = time)) + geom_point(size = 5) ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter() ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter(size = 5, alpha = 1/2) ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter(size = 5, alpha = 0.3) + geom_rug(col = &quot;steelblue&quot;, alpha = 0.1, size = 1.5) # add linear line or smoothing line ggplot(data = dd, aes(x = diagtime, y = time)) + geom_point() + geom_smooth(method = &quot;lm&quot;) ggplot(data = dd, aes(x = diagtime, y = time)) + geom_point() + geom_smooth(se = FALSE) ggplot(data = dd, aes(x = diagtime, y = time)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(se = FALSE) ## scatter plot + marginal distribution library(ggExtra) # classical p &lt;- ggplot(dd, aes(x = diagtime, y = time)) + geom_point() + theme(legend.position = &quot;none&quot;) # scatter plot + marginal histogram ggMarginal(p, type = &quot;histogram&quot;, color = &quot;purple&quot;) # scatter plot + marginal density ggMarginal(p, type = &quot;density&quot;) # scatter plot + marginal boxplot ggMarginal(p, type = &quot;boxplot&quot;) 5.5 混合變數 多變量視覺化分析 一連續 + 一類別 二連續 + 一類別 二類別 + 一連續 = 一連續 + 一類別 多變數 5.5.1 一連續 + 一類別 # one continuous + one categorical ggplot(data = dd, aes(x = time)) + geom_histogram(aes(fill = treat)) ggplot(data = dd, aes(x = time, fill = treat)) + geom_histogram( color = &quot;#e9ecef&quot;, alpha = 0.6, position = &#39;identity&#39;) ggplot(data = dd, aes(x = time, color = treat, fill = treat)) + geom_histogram() # ggplot(data = dd, aes(x = treat, y = time, fill = treat)) + geom_boxplot() ggplot(data = dd, aes(x = treat, y = time, fill = treat)) + geom_boxplot() + geom_jitter(color = &quot;purple&quot;, size = 2, alpha = 0.8) # ggplot(data = dd, aes(x = treat, y = time, fill = treat)) + geom_violin() ggplot(data = dd, aes(x = treat, y = time, fill = treat)) + geom_violin() + geom_jitter(color = &quot;purple&quot;, size = 2, alpha = 0.8) + ggtitle(&quot;Violin chart by treatment&quot;) + xlab(&quot;treatment&quot;) 5.5.2 二連續 + 一類別 ## ggplot2 ## two continuous + one categorical ggplot(data = dd, aes(x = diagtime, y = time, color = treat)) + geom_point(size = 4) ggplot(data = dd, aes(x = diagtime, y = time, color = treat)) + geom_jitter(size = 4) ggplot(data = dd, aes(x = diagtime, y = time, color = treat, shape = treat, size = treat)) + geom_jitter(alpha = 1/2) # add linear line or smoothing line ggplot(data = dd, aes(x = diagtime, y = time, color = treat, shape = treat)) + geom_point() + geom_smooth(method = &quot;lm&quot;) ggplot(data = dd, aes(x = diagtime, y = time, color = treat, shape = treat)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) # ggplot(data = dd, aes(x = diagtime, y = time, color = treat, shape = treat)) + geom_point() + geom_smooth(se = FALSE) # BAD! too many lines ggplot(data = dd, aes(x = diagtime, y = time, color = treat, shape = treat)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) + geom_smooth(se = FALSE) # classical p &lt;- ggplot(dd, aes(x = diagtime, y = time, color = treat)) + geom_point(size = 5) # scatter plot + marginal histogram ggExtra::ggMarginal(p, type = &quot;histogram&quot;, color = &quot;purple&quot;) 5.5.3 三連續變數 多連續變數: 檢視成對變數關聯性, 大小, 方向, 趨勢. ## pairwise scatter plot ## R base con.df = dd[, c(&quot;time&quot;, &quot;diagtime&quot;, &quot;kps&quot;, &quot;age&quot;)] cor.mat = cor(con.df, use = &quot;complete&quot;, method = &quot;pearson&quot;) round(cor.mat, 3) ## time diagtime kps age ## time 1.000 0.382 -0.046 -0.068 ## diagtime 0.382 1.000 -0.184 -0.095 ## kps -0.046 -0.184 1.000 -0.033 ## age -0.068 -0.095 -0.033 1.000 pairs(con.df) ## ggplot2 library(GGally) GGally::ggpairs(data = con.df) GGally::ggcorr(data = con.df, method = c(&quot;complete&quot;, &quot;pearson&quot;)) ## Correlogram library(corrgram) corrgram(x = dd, order = TRUE, lower.panel = panel.shade, upper.panel = panel.pie, text.panel = panel.txt, main = &quot;1. VA Lung Cancer Trial&quot;) corrgram(x = dd, order = TRUE, lower.panel = panel.ellipse, upper.panel = panel.pts, text.panel = panel.minmax, main = &quot;2. VA Lung Cancer Trial&quot;) corrgram(x = dd, order = NULL, lower.panel = panel.shade, upper.panel = NULL, text.panel = panel.txt, main = &quot;3. VA Lung Cancer Trial&quot;) Try by yourself! # more advanced my_fn &lt;- function(data, mapping, ...){ p &lt;- ggplot(data = data, mapping = mapping) + geom_point() + geom_smooth(method = loess, se = FALSE, fill = &quot;red&quot;, treat = &quot;red&quot;, ...) + geom_smooth(method = lm, se = FALSE, fill = &quot;blue&quot;, treat = &quot;blue&quot;, ...) p } GGally::ggpairs(data = con.df, lower = list(continuous = my_fn)) ## Bubble plot ggplot(data = dd, aes(x = diagtime, y = time, size = age)) + geom_point(alpha = 0.3) + scale_size(range = c(.1, 15), name=&quot;Age Bubbles&quot;) ggplot(data = dd, aes(x = diagtime, y = time, size = age)) + geom_point(alpha = 0.3) + scale_size(range = c(.1, 15), name=&quot;Age Bubbles&quot;) ggplot(data = dd, aes(x = diagtime, y = time, size = age, color = treat)) + geom_point(alpha = 0.3) + scale_size(range = c(.1, 24), name = &quot;&quot;) 5.6 分組繪圖 將資料依據組別分割成子資料集 將每個子資料集繪製在不同的圖格 將所有子資料集的圖格合併呈現 # plot by treat ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter() + facet_grid(. ~ treat) ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter() + facet_grid(treat ~ .) # plot by cellcode ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter() + facet_grid(. ~ cellcode) # two factors ggplot(data = dd, aes(x = diagtime, y = time)) + geom_jitter() + facet_grid(treat ~ cellcode) "],
["references.html", "References", " References Xie, Yihui. 2015. Dynamic Documents with R and Knitr. 2nd ed. Boca Raton, Florida: Chapman; Hall/CRC. http://yihui.org/knitr/. ———. 2020. Bookdown: Authoring Books and Technical Documents with R Markdown. https://CRAN.R-project.org/package=bookdown. "]
]
